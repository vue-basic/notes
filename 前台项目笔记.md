# day01
## 1.创建项目
* vue create gulishop-client2
* Default
* 注意:运行项目 看package.json
* npm run serve

## 2.认识项目目录及各个目录的作用
* node_modules  安装依赖
* public        公共的文件夹  主要用的是index.html
* src           主战场 写代码的地方
        assets      放的是各个组件共有的一个文件  静态文件  图片、css、js
        components  放的是非路由组件和组件间共用的一些组件
        App.vue     最后所有的组件要合并到这里
        main.js     渲染组件
* views/pages   路由组件

## 3.vue的main.js基本编码
```
import Vue from 'vue'
import App from './App.vue'

Vue.config.productionTip = false

new Vue({
  render: h => h(App)
}).$mount('#App')
```

```
import App from '@/App'
import Vue from 'vue'

Vue.config.productionTip = false

new Vue({
    el:"#app",
    render: h => h(App)
})
```
### [1]这样的写法会报错
```
import App from '@/App'
import Vue from 'vue'

Vue.config.productionTip = false

new Vue({
  el:'#app',

  //1.注册App组件进行使用,不过缺少解析器没法渲染,想用必须打入带解析器版本的js
  components:{
    App:App  //上面导入的App是定义组件所需的配置对象
  },
  template:'<App/>'
})
```

* You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build.
* 原因:没有解析器
* 代表确实用了template:'<App/>',但是没法渲染
* 默认引入的是vue.common.js
* "main":"dist/vue.runtime.common.js" 引入的这个js文件恰好是不带解析器版本的
* 解决方式:
* 引入带解析器版本的vue.esm.js 
* import Vue from 'vue/dist/vue.esm.js'

```
import App from '@/App'
// import Vue from 'vue'
import Vue from 'vue/dist/vue.esm.js'

Vue.config.productionTip = false

new Vue({
  el:'#app',
  components:{
    App:App  //上面导入的App是定义组件所需的配置对象
  },
  template:'<App/>'
})
```

### [2]render: h => h(App)
* 1.注册App组件
等价 === 
```
  components:{
    App //定义带注册  全写为 App:AppApp:App
  },
  template:'<App/>'
```

```
在外部
Vue.component('App',App)//定义带注册
```

### [3]想要使用组件的三大步
* 1.定义组件  定义组件的本质是定义了一个组件对象构造函数
* 2.注册组件  Vue.component('myh',VueComponent) ---全局注册 本质是给构造函数和一个名字进行关联
* 3.使用组件  <myh/>

* Vue.extend 最终返回的是一个构造函数
* 1.复杂写法
```
let VueComponent = Vue.extend({
  data(){

  },
  template:"<h2>你好啊</h2>"
})
```

* 2.简单写法  定义组件
```
// 定义带注册
Vue.component('myh',{
  data(){

  },
  template:"<h2>你好啊</h2>"
})

=== Vue.component('App',App)//定义带注册

// 使用组件
<myh/>

最终还是把配置对象交给extend,
1.通过配置对象先去创建一个组件对象的构造函数,
2.然后把这个构造函数跟 myh 这个名字进行关联,---注册
3.---使用

```

```
{
  data(){

  },
  template:"<h2>你好啊</h2>"
}
把这个配置对象拿出去写成了.vue文件  所以.vue文件相当于这个配置对象 所以.vue文件不是一个组件,而是一个配置对象 
组件不是.vue文件,组件是一个构造函数

```

### [4]render: h => h(App)
* 1.定义带注册
* 2.使用组件
* 3.渲染(依赖vue的一个loader去解析)
         npm install -D vue-loader vue-template-compiler
         vue-template-compiler ---- 解析模板

### [5]postman的使用
* 启动postman
* 点击+号
* 1.GET  
         拿服务器地址  http://182.92.128.115/
         拿请求地址    api/product/getBaseCategoryList
         http://182.92.128.115/api/product/getBaseCategoryList
         点击Send
         后期想用---保存
                点击Sava
                        request name
                        create folder
                        save to

* POST 
        服务器地址       http://182.92.128.115/
        登录地址         api/user/passport/login
        地址             http://182.92.128.115/api/user/passport/login
        路径中没有参数    没有query参数(/?key=value&key=value) , 也没有params参数(路径的一部分)
        请求体参数如何带？ mobile password  ----参数发送json格式  JSON是js当中的
            点击Body
            raw
            选中JSON
                    {
                        "mobile":"13700000000",
                        "password":"111111"
                    }

## 4.eslint错误级别禁用
* 新建文件  vue.config.js   ---放到项目最外层,不然不生效
```
module.exports = {
  		lintOnSave: false,
}
```

## 5.jsconfig.json配置别名@提示
* 新建文件 jsconfig.json
```
{
    "compilerOptions": {
      "baseUrl": "./",
      "paths": {
          "@/*": ["src/*"]
      }
    },
    "exclude": ["node_modules", "dist"]
  }

// compilerOptions : 解析选项
// baseUrl: 从哪开始
// paths :找谁 找@/
```
* 改完配置文件项目是要重启的 不然不生效

## 6.git的基本操作
* 我的本地提交步骤
* 1.git init
* 2.git remote add origin https://github.com/vue-basic/gulishop-client.git
* 3.git add -A
* 4.git commit -m "first commit"
* 5.git push -u origin master

## 7.观察页面确定页面主体框架
* 非路由组件和路由组件的区别 --- 注册的位置问题
* 非路由组件在App.js中的components中注册
      components:{
          Header,
          Main
      }
* 路由组件在路由的配置当中注册
    routes:[
        {
          path:'/home',
          component:Home,
        }
    ]

* 整个页面是单页面应用
### 1.路由组件  --- 中间的部分  点击不同的地方,在切换
* 登录  Login
* 注册  Register
* 首页  Home
* 搜索页 Search

### 2.非路由组件(写在components里边) --- 不管点谁是不变的  静态的非路由组件
* Header
* Footer

### 3.components 里边非路由组件
#### 1. 组件
```
1.定义
2.注册
3.使用
```
#### 2.定义组件
* Header
      index.vue
      images
          wx_cz.jpg  

* Footer
      index.vue
      images
            logo.png

* 静态页面(辉洪老师)
```
 1.html
 2.css
 3.img
 切记路径一定要配对
```

#### 3.在App.vue中 注册和使用组件
```
<template>
  <div>
  //3.使用
    <Header></Header>
    <Footer></Footer>
  </div>
</template>

<script>
//1.引入
import Header from '@/components/Header'
import Footer from '@/components/Footer'
export default {
  name:"App",
//2.注册
  components:{
    Header,
    Footer
  }
}
</script>
```

#### 4.报错
* 直接 npm install --save-dev less-loader less 就不会报错了
##### 1. ERROR  Failed to compile with 2 errors                                                                                                                                                             22:05:50
Failed to resolve loader: less-loader
You may need to install it.
Failed to resolve loader: less-loader
You may need to install it.

```
* devDependencies 开发时依赖   -D 打包  –save-dev || -D //开发依赖（辅助）
* dependencies    运行时依赖   -S  --save || -S // 运行依赖（发布）
```

* 原因:缺少less-loader
* 解决方案:
      npm i less-loader -D

##### 2.Error: Cannot find module 'less'
* 原因: 缺少less
* 解决方案: 安装less
* npm i less -D
* 找 webpack
      中文文档
          概念
              LOADERS
                  less-loader
* npm install --save-dev less-loader less

#### 5.Footer 里边的小黑点  ---- 样式  css初始化
* reset.css
* public
      css
          reset.css
* 在index.html中引入 reset.css
<link rel="stylesheet" href="./css/reset.css">
<link rel="stylesheet" href="/css/reset.css"> ---- 不带点(保证history模式也是可以的)

### 4.pages  定义路由组件的地方
* src
      pages
            Login
                index.vue
            Register
                index.vue
            Search
                index.vue
            Home
                index.vue
* 不管时路由组件还是非路由组件 都是三大步(定义、注册、使用)
* 路由组件的注册需要使用router的
#### 1.安装router
          npm i vue-router -S
#### 2.写配置  路由组件需要在路由当中去注册的  非路由组件直接放在App.vue中去注册就可以了
  src
      router
            index.js
            
* (1)router--->index.js
           
```
// 1.引入并声明使用
import VueRouter from 'vue-router'
import Vue from 'vue'

Vue.use()//声明使用

// 2.必须往外暴露一个路由器对象
export default new VueRouter({

})

// 3.必须在vue当中去注入(使用)路由器对象---在main.js当中去做
```

 * (2)main.js
 ```
 import App from '@/App'
// import Vue from 'vue'
import Vue from 'vue/dist/vue.esm.js'
import router from '@/router'

Vue.config.productionTip = false

new Vue({
  el:'#app',
  render: h => h(App),
  router,//router是配置对象的属性 不能改  
  // 配置对象是属性名固定,属性值不固定的对象
  // 让所有的组件当中都可以多两个对象  $router 和 $ route
})

 ```

 * $router 和  $route
    $router路由器对象
    $route路由对象
    $router路由器对象身上会有 push 和 replace
    this.$router.push('./search')//push(可以写字符串/对象)

* (3)此时路由器已经生效了  但是现在路由器还没有管理路由  需要自己配置
  路由:路径和一个玩意的映射关系
  路由分为前台路由和后台路由
  后台路由时路径和函数的映射关系
  前台路由时路径和组件的映射关系
  每一个路由代表是一个对象

```
// 引入组件
import Home from '@/pages/Home'
import Search from '@/pages/Search'
import Register from '@/pages/Register'
import Login from '@/pages/Login'

// 2.必须往外暴露一个路由器对象
export default new VueRouter({
    routers:[
        {
            path:'/home',
            component:Home
        },
        {
            path:'/search',
            component:Search
        },
        {
            path:'/register',
            component:Register
        },
        {
            path:'/login',
            component:Login
        },
          // 重定向路由
        {
            path:'/', //当你访问/的时候,重定向跳转到home页
            redirect:'/home'
        }
    ]
})

```

* (4).显示路由组件  
<router-link/>
<router-view/>
在哪里需要显示路由组件就需要在哪里留坑  
留坑就是写上<router-view></router-view> 

[1]在App.vue中留坑
```
  <Header></Header>
    <router-view></router-view>
  <Footer></Footer>
```

[2]点击谁才去显示  <router-link></router-link> 点击的人在Header当中  本质上 router-link 最后解析完了也是a标签
```
 <router-link to="/login">登录</router-link>
 <!-- <a href="###">登录</a> -->
 <!-- <a href="###" class="register">免费注册</a> -->
 <router-link class="register" to="/register">免费注册</router-link>

  <router-link class="logo" to="/">
    <img src="./images/logo.png" alt="">
  </router-link>
  <!-- <a class="logo" title="尚品汇" href="###" target="_blank">
            <img src="./images/logo.png" alt="">
        </a> -->
```

## 10、配置路由在对应点击切换路由组件的位置，替换路由链接	
### 1..声明式导航和编程式导航
* 声明式导航  你说它就给你做  
  比如: router-link  你告诉它往哪跳就往哪跳

* 编程式导航  自己写代码告诉它往哪跳 而且自己写代码的时候是可以往里边加一些功能的,比声明式导航功能要丰富，而且效率也比声明式导航要快
```
 <button class="sui-btn btn-xlarge btn-danger" type="button" @click="toSearch">搜索</button>

 methods:{
        toSearch(){
            this.$router.push('/search')//push(可以写字符串/对象)
        }
    }
```

### 2..报错
* 1. Uncaught RangeError: Invalid array length
     解决方案: 
```
Vue.use(VueRouter)//声明使用 告诉它我要用哪个
```

* 2. [Vue warn]: Unknown custom element: <router-view> - did you register the component correctly? For recursive components, make sure to provide the "name" option.
```
       Vue.use(VueRouter)//声明使用 告诉它我要用哪个
       在mian.js中查看vue的引入版本
       import Vue from 'vue'  引入这个就不会包上面的错误(切记！！！！！！！！)
       import Vue from 'vue/dist/vue.esm.js' 引入这个版本就会报上面的错误
```
* 3.<router-view></router-view>内容无法渲染出来---神坑
    配置路由时注意,名字定义为routes而不是routers

* 4.Search页面切换不出来   (切记单词不要写错！！！！！！！)
```
  {
            path:'/search',
            component:Search
        },
```
## 11.登录注册不需要Footer,通过路由meta配置解决
```
这个组件标签必然要写v-show  v-if
而且要看切换的频率高不高
切换频率高用 v-show
切换频率不高  v-if
最大区别:
v-if 条件为假  直接在dom树上剁了 通过ref去获取的时候是获取不到的
v-show 通过display:none;去隐藏的 是通过css去做的  通过ref是可以获取到的
ref标记某一个元素可以通过this.$refs._可以拿到
如果用v-if 条件为真 this.$refs._可以拿到
          条件为假 this.$refs._拿不到
用v-show一定能拿到
```

* 1.不推荐使用
```
<Footer v-show="!(this.$route.path === '/login' || this.$route.path === '/register')"></Footer>
<!-- this.$route.path 从当前的路由对象中去找 拿到path 判断你的path是不是我要找的path -->
```

* 2.用mata元配置(推荐使用)
```
 <Footer v-show="!$route.meta.isHide"></Footer>

 配置路由  router --- > index.js

        {
            path:'/register',
            component:Register,
            meta:{
                isHide:true
            }
        },
        {
            path:'/login',
            component:Login,
            meta:{
                //meta：元 元设置项  --- 基础的、细微的设置
                isHide:true
            }
        },
```




# day02
## 12、路由传参相关
### 1.路由跳转的两种方式
* 声明式 <router-link to=""></router-link>
  
* 编程式 this.$router.push() / this.$router.replace()

* 当你自己想要在路由跳转的时候添加一些功能的用编程式,而声明式是不会给你添加自己功能的机会的

### 2.路由跳转携带参数的2种方式
* params参数    属于路径的一部分
    接收params参数  path:'/login:num'
* query参数     属于查询参数,不属于路径  ?key=value&key=value  ?区分路径和查询参数       
    协议、IP、端口、路径 ? 查询参数

* url包含三部分:协议 IP 端口 http://localhost:8080/路径

#### (1)声明式和编程式的两种写法
* 1.字符串写法
```
<router-link to="/login">登录</router-link>
```

```
 this.$router.push('/search')
```
* 2.对象写法(推荐使用)
```
<router-link :to="{path:'/login'}">登录</router-link>
```

```
this.$router.push({path:'/search'})
```

#### 2.收集参数
Header --- index.vue 
```
<input type="text" id="autocomplete" class="input-error input-xxlarge" v-model="keyword"/>

收集在data当中
data() {
        return {
            keyword:''
        }
    },
```

* 携带params参数的对象写法
```
this.$router.push({path:'/search/',params:{keyword:this.keyword}})

当我一点击,它去push的时候,把keyword通过params参数带过去
```

* 携带params参数的字符串写法
```
 this.$router.push('/search/'+this.keyword)
```

#### 3.params参数能不能和path配合?
  *   1.字符串形式 params参数可以和字符串写法的path配合
        this.$router.push('/search/'+this.keyword) 可以 push的路径一定要和path的路径一样

  *   2.自己知道keyword是参数,需要在router --- index.js 里边接收
    ```
    接收params参数
        {
            path:'/search/:keyword',
            component:Search
        },
    ```

  *  3.params参数不能和对象写法的path配合,如果要配合只能和name配合
    ```
    传递params参数的对象写法和path配合是错误的
    this.$router.push({path:'/search/',params:{keyword:this.keyword}})
    ```

    ```
    router --- index.js
        {
            path:'/search/:keyword',
            component:Search,
            name:'search'
        }

    Header --- index.vue
         this.$router.push({name:'search',params:{keyword:this.keyword}})
    ```

  * 4.如果只传query参数可以和path配合
  * 5.如果传递的参数有params参数也有query参数,那么直接用name就可以,因为query参数也可以和name配合

  #### 4.面试问题
  ##### 1. 指定params参数可不可以用path和params配置的组合?(对象写法)
  * 不可以用path和params配置的组合
  * 只能用name和params配置的组合
  * query配置可以与path或name进行组合使用

  ##### 2. 如何指定params参数可传可不传?
  * path:'/search/:keyword?'  
  * keyword 有时候传有时候不传 在 keyword后边加个?就可以了
  * 如果params参数有时候传有时候不传,那么在路由配置的时候路径接收的参数后面添加?  
  * ? 代表它前面的params参数可传可不传

  ##### 3.params参数和name配合了,但是传递的是一个空串,那么路径也会出问题
  * this.$router.push({name:'search',params:{keyword:""}})   ---- 路径会出问题
  * 解决：
          1.首先要配置可传可不传
          2.传递参数的时候要么不写params,要么传递undefined替代

```
1.
        {
            path:'/search/:keyword?',
            component:Search,
            name:'search'
        },

2.
 this.$router.push({name:'search',params:{keyword:this.keyword || undefined}})  推荐使用
 this.$router.push({name:'search'})

```

* &&
      1.前面为真则取后边的值作为整个表达式的值
      2.前面为假则取前面的值作为整个表达式的值
* ||  
      1.前面为真则取前面的值作为整个表达式的值
      2.前面为假则取后面的值作为整个表达式的值   

##### 4.路由组件能不能传递props数据?
* 可以:可以将query或者 params参数映射/转换成props传递给路由组件对象
###### 1. props 路由配置(三种写法) props这个属性用来配置传递参数的简便方式
  * 1.布尔值  如果写为true 代表路由对象把接收的params参数作为属性映射到要显示的路由组件当中
    ```
    1.router --- index.js

     {
            path:'/search/:keyword?',
            component:Search,
            name:'search',
            props:true
            // props这个属性用来配置传递参数的简便方式
            // 1.布尔值  如果写为true 代表路由对象把接收的params参数作为属性映射到要显示的路由组件当中
        },

    2.Search --- index.vue

        export default {
            name:"Search",
            props:['keyword']
        }

    3.用法  模板中用
    {{$route.params.keyword}} ---复杂写法

    {{keyword}} --- props 的简便写法
    ```

  * 2.对象写法  如果写为对象,目的是额外的往要显示的路由组件当中传递一些静态数据用的
  ```
  1.router --- index.js
  props:{name:'zhaoliying'} ---一般情况下没有任何意义

  2. Search --- index.vue 接收props
  props:['keyword','name']

  3.模板中使用
  name:{{name}}
  ```

  * 3.函数写法  函数写法是用的最多的,因为它不但可以映射params还可以映射query
 ```
 * Header  index.vue
            let location ={
                name:'search',
                params:{keyword:this.keyword || undefined},
                query:{keyword2:this.keyword.toUpperCase()}
            };
            this.$router.push(location)


  1.router --- index.js
            props(route){
                // route是接受完参数的路由对象
                return {
                    // 自己映射
                    // 把路由对象接收到的参数,无论什么参数,自己手动映射为路由组件的属性
                    keyword:route.params.keyword, 
                    keyword2:route.query.keyword
                }
            }
            
    接收params参数一定要用':'先占位,不然接不到params参数  ：
        {
            path:'/search/:keyword',
            component:Search,
            name:'search',
            // props:true
            // props:{name:'zhaoliying'}
            props(route){
                return {
                    keyword:route.params.keyword,
                    keyword2:route.query.keyword2
                }
            }
        },

  2.Search ---- index.vue 接收参数
  props:['keyword','keyword2'] 

  3.模板中使用
     params参数:{{$route.params.keyword}}  ---- {{keyword}}
     query参数:{{$route.query.keyword2}}   ---- {{keyword2}}
   
 ```
##### 5.编程式路由跳转到当前路由(参数不变),多次执行会抛出 NavigationDuplicated 的警告错误
* vue-router.esm.js?8c4f:1998 Uncaught (in promise) NavigationDuplicated: Avoided redundant navigation to current location: "/search/aa?keyword2=AA".
* 原因: vue-router 3.1.0之后,无论用的是 push() 还是 replace(),最终都返回Promise
        而你对这个Promise没做处理
        所以它就会报警告
        this.$router.push(location)

* 方案一：
```
        this.$router.push(location).catch(()=>{})

        这个push调的是路由器对象的push,
        而路由器对象是你在 router ---- index.vue new VueRouter()出来的
        而push方法是VueRouter显式原型对象当中的push
        VueRouter显式原型上的方法是让它的实例化对象用的
        this.$router就是VueRouter的实例化对象
        this.$router调push方法,这个方法要么是它自己身上的,要么是它原型身上的
        而this.$router的隐式原型就是 VueRouter的显式原型

        构造函数的显式原型就是这个构造函数实例化出来的实例化对象的隐式原型
        所有的对象分为两大类:函数对象和非函数对象
        只有函数对象才有prototype---只有函数对象才有显式原型

        而this.$router是由VueRouter实例化出来的,this.$router身上没有prototype  
        它身上只有__proto__,
        push是VueRouter显式原型的方法
```

* 方案二:
```
 this.$router.push(location,()=>{},()=>{})
 如果没有
```

* 方案三(最佳方案 只需要处理一下就可以了) router--- index.js
```
const originPush = VueRouter.prototype.push
const originReplace = VueRouter.prototype.replace
// 把VueRouter原型上的push方法先保存起来 后期要用的


VueRouter.prototype.push = function(location,onResolved,onRejected){
    // 把它原来的push重新指向
    if(onResolved === undefined && onRejected === undefined){
        // 代表没有传递处理的回调无论是成功还是失败
        return originPush.call(this,location).catch(()=>{})
        // this代表VueRouter的实例化对象 ---- 路由对象  
        // originPush不.call的话是window在调
    }else{
        return originPush.call(this,location,onResolved,onRejected)
    }
}


VueRouter.prototype.replace = function(location,onResolved,onRejected){
    // 把它原来的push重新指向
    if(onResolved === undefined && onRejected === undefined){
        // 代表没有传递处理的回调无论是成功还是失败
        return originReplace.call(this,location).catch(()=>{})
        // this代表VueRouter的实例化对象 ---- 路由对象  
        // originPush不.call的话是window在调
    }else{
        return originReplace.call(this,location,onResolved,onRejected)
    }
}
```


##### 报错 These dependencies were not found:

* core-js/modules/es.regexp.exec in ./src/router/index.js
* core-js/modules/es.string.replace in ./src/router/index.js

To install them, you can run: npm install --save core-js/modules/es.regexp.exec core-js/modules/es.string.replace

* 解决方案:    npm install --save core-js

```
总结:

原因: 
    vue-router 3.1.0之后,引入Promise的语法

    如果没有通过参数指定成功或者失败  回调函数就返回一个promise

    且内部会判断如果要跳转的路径和参数有没有变化

解决：

    1.在跳转时指定成功或失败的回调函数,或者catch处理错误

    2.修改Vue原型上的push和replace方法(推荐使用)
```


 #### 5.知识点补充
* 1.vue-router 是什么?
```
是vue官方的一个插件

专门用来实现一个SPA应用

基于Vue的项目基本都会用到此库

vue  vue-router 这两个插件应用比较广泛
```

* 2.单页面Web应用  SPA
```
整个应用只有一个完整的页面(这个完整的页面,由多个组件组成)

点击页面中的链接不会刷新页面,本身也不会向服务器发请求

当点击链接时,只会做页面的局部更新(组件切换)

数据都需要通过ajax请求获取,并在前端一部展现
```

* 3.路由组件和非路由组件的最大区别
```
路由组件的生命周期是点击链接的时候 才开始的  ,  路由组件才会创建,mounted才能执行

路由组件在切换的时候, 会被销毁 ,显示的时候重新创建

同一个路由组件传参显示是不同的数据 , mounted回调只会执行一次 ,因为是一个组件

只有切换的时候才会销毁,如果没有切换,只有路由在变化,但是组件没变  是不会销毁的
```

* 4.路由传参过程
```
1.点击
  当你一点击,必然有一个路径

      router-link to="路径"

      this.$router.push("路径")

      这个路径会去到路由器当中去匹配路径

      从上往下匹配必然有一个和它匹配成功

      如果一旦匹配成功,下边就不匹配了
      
  路由器中的路由2中的path刚好和我的path匹配上了

  匹配上:匹配路径、解析路径当中带的参数

      路径当中有可能带params参数,有可能带query参数

      它会把路径中的params参数和query参数全部解析出来

      把params参数和query参数解析出来后添加到匹配上的那个路由对象中去
      
      匹配上的路由对象:
       {
            path:'/search/:keyword?',
            component:Search,
            name:'search',
       }

      匹配完成的路由对象
       {
            path:'/search/:keyword?',
            component:Search,
            name:'search',
            params:{},
            query:{}
       }
       此时匹配就算结束了

  显示组件
      把匹配完成的路由对象扔到组件对象当中来

        从组件当中可以通过this.$route找到一个路由对象,而这个路由对象就是你刚才扔过来的路由对象

    路由中如果写了props,只是在做一个额外的简化操作,

    可以让我们把收集到的params参数和query参数,通过props映射为路由组件的属性去处理


```

* 5.Promise
```
Promise对象用于表示一个异步操作的最终完成(或失败),及其结果值
```

## 13.
* 定义全局组件,并且全局注册  type-Nav 
* 定义局部组件

* components：非路由组件(一级路由的非路由组件) | 公共的非路由组件
* type-Nav 不是路由组件  但是被多个组件共用 所以把它也放在components里边
* Home Search 是路由组件  type-Nav是路由组件中的非路由组件

### 1.TypeNav
components
        TypeNav  ---- 公共的非路由组件
                index.vue
* 1. 定义组件
                ```
                定义组件
                拿辉洪老师的
                    html
                    css
                    images
                ```
* 2. 全局注册组件 在 main.js 中
```
main.js

// 全局注册的各种组件,因为很多地方用到 
// SPA 单页面应用  main.js 是首先要加载的入口

import TypeNav from '@/components/TypeNav'

Vue.component('TypeNav',TypeNav)//全局注册
```

* 3.使用组件(在Home&&Search中使用)
<TypeNav></TypeNav>

### 2.ListContainer
Home
    ListContainer
          index.vue
* 1.定义组件
```
拿辉洪老师的
    html
    css
    images
```
* 2.在Home --- index.vue 中注册并使用组件
```
<template>
    <div>
        <TypeNav></TypeNav>
        <ListContainer></ListContainer>
    </div>
</template>

<script>
import ListContainer from './ListContainer'
export default {
    name:'Home',
    components:{
        ListContainer
    }
}
</script>
```

### 3. Recommend
Home
    Recommend
          index.vue
* 1.定义组件
```
拿辉洪老师的
    html
    css
    images
```
* 2.在 Home --- index.vue 中注册并使用组件
```
<template>
    <div>
        <TypeNav></TypeNav>
        <ListContainer></ListContainer>
        <Recommend></Recommend>
    </div>
</template>

<script>
import ListContainer from './ListContainer'
import Recommend from './Recommend'
export default {
    name:'Home',
    components:{
        ListContainer,
        Recommend
    }
}
</script>
```

### 4.Rank
* 1.定义组件
```
拿辉洪老师的
    html
    css
    images
```

* 2.注册并使用组件 Home --- index.vue
```
<template>
    <div>
        <TypeNav></TypeNav>
        <ListContainer></ListContainer>
        <Recommend></Recommend>
        <Rank></Rank>
    </div>
</template>

<script>
import ListContainer from './ListContainer'
import Recommend from './Recommend'
import Rank from './Rank'
export default {
    name:'Home',
    components:{
        ListContainer,
        Recommend,
        Rank
    }
}
</script>
```

### 5.Like
* 1.定义组件
```
拿辉洪老师的
    html
    css
    images
```
* 2.在Home --- index.vue 中注册并使用
```
<template>
    <div>
        <TypeNav></TypeNav>
        <ListContainer></ListContainer>
        <Recommend></Recommend>
        <Rank></Rank>
        <Like></Like>
    </div>
</template>

<script>
import ListContainer from './ListContainer'
import Recommend from './Recommend'
import Rank from './Rank'
import Like from './Like'
export default {
    name:'Home',
    components:{
        ListContainer,
        Recommend,
        Rank,
        Like
    }
}
</script>
```
### 6.Floor
* 1.定义组件
```
拿辉洪老师的
    html
    css
    images
```
* 2.在Home --- index.vue 中注册并使用
```
<template>
    <div>
        <TypeNav></TypeNav>
        <ListContainer></ListContainer>
        <Recommend></Recommend>
        <Rank></Rank>
        <Like></Like>
        <Floor></Floor>
        <Floor></Floor>
    </div>
</template>

<script>
import ListContainer from './ListContainer'
import Recommend from './Recommend'
import Rank from './Rank'
import Like from './Like'
import Floor from './Floor'
export default {
    name:'Home',
    components:{
        ListContainer,
        Recommend,
        Rank,
        Like,
        Floor
    }
}
</script>
```

### 7.Brand
* 1.定义组件
```
拿辉洪老师的
    html
    css
    images
```
* 
```
<template>
    <div>
        <TypeNav></TypeNav>
        <ListContainer></ListContainer>
        <Recommend></Recommend>
        <Rank></Rank>
        <Like></Like>
        <Floor></Floor>
        <Floor></Floor>
        <Brand></Brand>
    </div>
</template>

<script>
import ListContainer from './ListContainer'
import Recommend from './Recommend'
import Rank from './Rank'
import Like from './Like'
import Floor from './Floor'
import Brand from './Brand'
export default {
    name:'Home',
    components:{
        ListContainer,
        Recommend,
        Rank,
        Like,
        Floor,
        Brand
    }
}
</script>
```

## 14.组件介绍
* TypeNav         包含导航  三级分类列表(数据是真实的)需要发请求去拿的
* ListContainer   数据是假的 没有接口  mock数据
* Recommend       数据是假的 没有接口   不做 ×
* Rank            数据是假的 没有接口   不做 ×
* Like            数据是假的 没有接口   不做 ×
* Floor           没有接口  mock数据
* Brand           没有接口   不做 ×

### 1.TypeNav 三级列表数据 
* 发请求 用  axios  不用原生(xhr)的  用封装好的axios
* xhr + promise => axios

#### 1.对axios进行二次封装  (不会找基偶)
* 函数用法  axios({配置对象})
* 对象用法  axios.get()
* axios.create()? 
        axios配置了url之后只能往一台服务器上发请求
        axios想往多台服务器发送请求,只能通过create创建新的axios实例去发
        axios本身是可以配置url的,url配置的是服务器地址  baseUrl

* npm i axios -S
src     
    ajax
        Ajax.js

##### 1.要实现的功能
```
1.配置基础路径和超时限制

2.添加进度条信息  nprogress

3.返回的响应不再需要从data属性当中拿数据，而是响应就是我们要的数据

4.统一处理请求错误, 具体请求也可以选择处理或不处理
```

##### 2.请求拦截器和响应拦截器
```
// 2.添加进度条信息  nprogress
/**
 * 用到请求拦截器和响应拦截器
 * 
 * 请求拦截器:
 *          1.可以在请求时候添加功能
 *          2.我们可以对请求报文进行处理
 * 
 * 响应拦截器:
 *          1.可以添加功能
 *          2.可以处理响应报文信息
 * 
 * 找到Interceptors
 * 只需要把axios换成instance
 * create创建出来的其实就相当于一个新的axios
 * 
 * 用到一个插件 nprogress
 * 
 * 1.用到 nprogress 中的js和css
 * <script src='nprogress.js'></script>
 * <link rel='stylesheet' href='nprogress.css'/>
 * 
 * 2.安装 nprogress
 * 安装 $ npm install --save nprogress
 * 
 * 3.最终要用的
 * NProgress.start();  请求拦截器中开始
 * NProgress.done();   响应拦截器中结束
```

##### 3.安装 nprogress
npm install --save nprogress

##### 4.二次封装axios---Ajax.js

* 把axios用instance替换,并在最后暴露出去

```
import axios from 'axios'
import NProgress from 'nprogress' //相当于导入了js <script src='nprogress.js'></script>
import 'nprogress/nprogress.css' //引入css

/**
        1.配置基础路径和超时限制

		2.添加进度条信息  nprogress

		3.返回的响应不再需要从data属性当中拿数据，而是响应就是我们要的数据

		4.统一处理请求错误, 具体请求也可以选择处理或不处理
  
 */

// 1.配置基础路径和超时限制
const instance = axios.create({
    baseURL: '/api',//配公共路径  请求路径当中公共的路径
    timeout: 20000,
  });

// 2.添加进度条信息  nprogress
/**
 * 用到请求拦截器和响应拦截器
 * 
 * 请求拦截器:
 *          1.可以在请求时候添加功能
 *          2.我们可以对请求报文进行处理
 * 
 * 响应拦截器:
 *          1.可以添加功能
 *          2.可以处理响应报文信息
 * 
 * 找到Interceptors
 * 只需要把axios换成instance
 * create创建出来的其实就相当于一个新的axios
 * 
 * 用到一个插件 nprogress
 * 
 * 1.用到 nprogress 中的js和css
 * <script src='nprogress.js'></script>
 * <link rel='stylesheet' href='nprogress.css'/>
 * 
 * 2.安装 nprogress
 * 安装 $ npm install --save nprogress
 * 
 * 3.最终要用的
 * NProgress.start();  请求拦截器中开始
 * NProgress.done();   响应拦截器中结束
 * 
 * 
 * 
 */

//  在请求拦截器中不需要写失败的回调---发请求失败了没意义
instance.interceptors.request.use( config => {
    // config就是你的请求报文对象,可以这么理解
    /**
     *  1.可以在请求时候添加功能
     *  2.我们可以对请求报文进行处理
     */
    NProgress.start();//添加进度条功能

    return config;//一定要把config返回去
  })


//   3.返回的响应不再需要从data属性当中拿数据，而是响应就是我们要的数据

instance.interceptors.response.use(
    response => {
        NProgress.done();
        return response.data;
  }, 
    error => {
        NProgress.done();
    //   4.统一处理请求错误, 具体请求也可以选择处理或不处理
    alert('发送ajax请求失败'+error.message || '未知错误')
    // 错误了之后可以选择今后可以继续处理这个错误,也可以选择今后不能处理这个错误

    //  return Promise.reject(error);//返回的是失败的promise,是可以让后续继续处理这个错误的
    //  如果不想让他处理  中断Promise链 返回一个pending状态的promise
    return new Promise(()=>{})
  }
)

// 暴露出去
export default instance
```

##### 5.NProgress不要忘记结束
* NProgress.start();  请求拦截器中开始
* NProgress.done();   响应拦截器中结束

##### 6.把封装好的新的axios实例instance最终一定要暴露出去
  export default instance


#### 2.拦截器
前端                                                             |                                后端
button                                          
你一点击button,它就要发送一个请求(ajax请求),
可以把这个请求当作一个信号/水流
请求往后端去跑                                   ----------》                         后端接收这个请求的时候,会从后端调一个函数
                                                                                    这个函数会从数据库里边拿数据进行序列化,序列化成json
                                                                                     然后把json封装成一个 response 返回给前端
                                                《-----------
                                        添加了两个钩子：请求拦截器和响应拦截器
 ```                                       
        请求拦截器
但你这个请求往后端去发的时候,
但是还没有出前端---可以把它请求的报文拦截下来
通过一个函数可以拦截到它的请求报文,对它的请求报文进行处理
处理完成后再把这个报文返回去,因为这个报文还是要往后端跑的   
 ```

                                                    响应拦截器
                                            报文到后端一旦处理完成，就会返回前端一个响应
                                            响应拦截器是在返回到前端之前,还没有进入前端  
                                            在报文进入前端之前留了一个钩子，你可以把它的响应报文拿到进行处理,
                                            处理完成后返回去继续传到前端
请求拦截器和响应拦截器是留了两个机会,对你发出的请求进行处理,对你返回的响应进行干预


## 15.postman 测试后台api接口,保存请求信息以便后期使用(参考接口文档)
src
    api
        index.js 
        用来书写所有的接口请求函数
        15个接口,每一个接口我们都去封装一个函数来对应
        以后哪里需要数据,那我就调哪一个相应的接口请求函数就ok

### 1.写接口请求函数
* 1.api---index.js
```
// 用来书写所有的接口请求函数
// 15个接口,每一个接口我们都去封装一个函数来对应
// 以后哪里需要数据,那我就调哪一个相应的接口请求函数就ok
// 一旦写接口请求函数,必然要用到axios  用封装好的

import Ajax from '@/ajax/Ajax'

// 1.请求三级分类列表数据函数
/**
 * 请求地址:/api/product/getBaseCategoryList
 * 请求方式:GET
 * 参数:无
 */
// 相当于定义一个函数,把这个函数暴露出去,后期想用直接调就可以了
export const reqCategoryList = () => {
    return Ajax({
        // axios的函数用法
        // 配置对象:属性名固定,属性值不固定
        url:'/product/getBaseCategoryList' ,//api不用配了,因为刚才在公共的路径中已经配了
        method:'get',
    })
}
```
### 2.测试接口(两种方法)
#### 1.直接调这个暴露出来的函数  需要在main.js中加载一下 因为模块不会自己运行
* reqCategoryList() ---- api---index.js
* import '@/api' ---- main.js

#### 2.在main.js中调暴露出来的这个函数
* import {reqCategoryList} from '@/api'  ---先解构赋值
* reqCategoryList()

### 3.解决跨域问题
* 发送ajax请求失败Request failed with status code 404
* Request URL: http://localhost:8080/api/product/getBaseCategoryList  ---- 没有解决跨域

* http://182.92.128.115/ --- 应该发送请求的地址(开发服务器地址)

#### 1.在vue.config.js中配置 (webpack官网)
webpack中文网
        中文文档
            配置
                开发中 Server(devServer)
                    devServer.proxy

```
proxy: {
  "/api": {
    target: "http://localhost:3000",
    pathRewrite: {"^/api" : ""}
  }
}
```
* 1.vue.config.js
```
module.exports = {
    lintOnSave: false,
    devServer:{
        proxy: {
            "/api": {
              target: "http://182.92.128.115/",
              pathRewrite: {"^/api" : ""}
            }
          }
    }
}
```
* 2.重启项目
* 3.数据获取到了 
* 配置代理
```
 配置代理其实就是把服务器转发了一下,把本地的服务器转发到 http://182.92.128.115/,而路径并没有改
 http://localhost:8080/api/product/getBaseCategoryList
 只是把路径前面的协议、IP、端口给改了
```

##### 什么是跨域？(只有ajax请求才会出现跨域问题)
```
跨域是存在于浏览器上的同源验证规则,跨域问题只存在于浏览器上

用代理服务器解决跨域问题是把浏览器和服务器之间的交道---转化成---服务器和服务器之间的交道

而服务器和服务器之间不存在跨域问题
```

### 4.数据存哪？ vuex
* npm i vuex -S
src
    store
            index.js
#### 1.vuex
```
// 1.引入并声明使用

import Vue from 'vue'
import Vuex from 'vuex'
Vue.use(Vuex)

// 存数据的地方,多个属性的对象
// 3.把数据存起来
const state = {}

// 直接修改数据的地方,是多个方法的一个对象  方法当中不能出现 if for 异步操作
// 2.提交给mutations修改数据
const mutations = {}

// 和用户对接的地方 也是多个方法的一个对象 可以出现 if for 异步操作
// 1.发请求  用户dispatch
const actions = {}

// 通过state计算出来的属性数据(只有读没有写,只能使用state数据,不能修改state数据)
const getters = {}

// 2.向外暴露一个Store对象
export default new Vuex.Store({
    state,
    mutations,
    actions,
    getters
})

// 3.注入这个创建的这个store对象,在vue当中
// 在main.js中注入
```


#### 2.在main.js中注入store对象
import store from '@/store'

store,//让所有的组件当中都可以多一个对象  this.$store

#### 3.modules(vuex的核心概念---五)
store
    home.js
    user.js
    search.js

##### 1.user.js home.js search.js
```
const state = {}

const mutations = {}

const actions = {}

const getters = {}

export default {
    state,
    mutations,
    actions,
    getters
}
```

* 最终都要合并到 store --- index.js 中来
```
1.引入
import home from './home'
import user from './user'
import search from './search'

2. 把每个小模块的小store合并到大store
    modules:{
        home,
        user,
        search
    }
```

##### 2.store --- index.js
```
// 1.引入并声明使用

import Vue from 'vue'
import Vuex from 'vuex'
Vue.use(Vuex)

import home from './home'
import user from './user'
import search from './search'

// 存数据的地方,多个属性的对象
// 3.把数据存起来
const state = {}

// 直接修改数据的地方,是多个方法的一个对象  方法当中不能出现 if for 异步操作
// 2.提交给mutations修改数据
const mutations = {}

// 和用户对接的地方 也是多个方法的一个对象 可以出现 if for 异步操作
// 1.发请求  用户dispatch
const actions = {}

// 通过state计算出来的属性数据(只有读没有写,只能使用state数据,不能修改state数据)
const getters = {}

// 2.向外暴露一个Store对象
export default new Vuex.Store({
    state,
    mutations,
    actions,
    getters,
    // 把每个小模块的小store合并到大store
    modules:{
        home,
        user,
        search
    }
})

// 3.注入这个创建的这个store对象,在vue当中
// 在main.js中注入
```

* 只有store当中的state会分对象存储,其他的不会

##### 3.home页的数据 home.js
* 三连环找对应的模块去写,不要在总的store中去写
* store --- index.js 就是用来 合并的

* 三连环(重要！！！！)
```
import {reqCategoryList} from '@/api' //引入接口请求函数  并把main中测试的给删掉

// 存数据的地方,多个属性的对象
// 3.把数据存起来
const state = {
    categoryList:[]   //初始化存储的共享状态数据 
}
// RECEIVECATEGORYLIST 这个函数一触发给state里边保存数据

// 直接修改数据的地方,是多个方法的一个对象   方法当中不能出现  if for 异步操作
// 2.提交给mutations修改数据
const mutations = {
    // mutations当中的函数名都是要大写的
    RECEIVECATEGORYLIST(state,categoryList){
        state.categoryList = categoryList
    }
    // 有人commit的时候RECEIVECATEGORYLIST这个函数才会执行
}

// 和用户对接的地方,也是多个方法的一个对象  可以出现 if for 异步操作
// 1.发请求 用户dispatch
const actions = {
    async getCategoryList({commit}){
        const result = await reqCategoryList()
        //调用这个函数相当于在调api中的这个函数 它会返回一个Ajax最后的调用结果 它的调用结果是一个Promise
        // 想要拿数据就.then 但是我们用async await

        if(result.code === 200){
            commit('RECEIVECATEGORYLIST',result.data)
            // 提交给响应的mutations去修改相应的数据
        }
    }
}
// actions当中发请求拿数据commit
// 当用户一旦dispactch它 getCategoryList就发请求

// 通过state计算出来的属性数据(只有读没有写,只能使用state数据,不能修改state数据)
const getters = {}


export default {
    state,
    mutations,
    actions,
    getters
}
```

* 三连环写完了之后,请求还没有发,在action被触发的时候请求才会发  用户/组件会告诉你什么时候发
* 后期发请求都是在mounted中发的 mounted代表模板挂载完成后---模板变为真正的dom
* 在mounted之前一切的东西都是放在模板里边.,而div是挂载点,它下边根本什么东西都没有
* 只有mounted之后,div下边才有东西,它一旦有东西,就让它发请求
* 发请求

##### 5.categoryList --- 放到 TypeNav里边
* 1.用户dispatch actions  (TypeNav---index.vue)
```
  mounted(){
        // 挂载完成后(模板挂载完成后,模板变成真正的dom后)
       this.getCategoryList()
    },
    methods:{
        getCategoryList(){
            this.$store.dispatch('getCategoryList')
        }
    },
```
* 组件当中用户dispatch的时候才会触发三连环
* 你写完了vuex之后不代表它就发请求拿数据了,你的让它触发这个actions
    this.$store.dispatch('getCategoryList') 
* 1.Vue组件当中的东西
    拿的是Vue组件当中的东西
    一发请求数据数据没有去到组件当中,而是在 2. vuex里边
    数据还是在vuex的store当中
* 2.vuex中的数据
    只能够看到每一次调用mutations的记录
    这个数据已经存储到vuex里边了



# day03
## 19.获取到数据后显示三级分类列表 TypeNav---index.vue
### 1.捞数据 在TypeNav里边展示数据  捞数据通常情况下用的是computed --- 计算属性
* mounted 
``` 
  mounted(){
        // 挂载完成后(模板挂载完成后,模板变成真正的dom后)
        this.getCategoryList()
    },
```
* computed --- 用来拿数据 
               可以去拿Vuex当中state及getters当中的数据
* methods 
               可以获取Vuex当中mutations和actions方法
```
    methods:{
        getCategoryList(){
            // 用户在触发相应的actions去发请求拿数据
            this.$store.dispatch('getCategoryList') //名字刚好和函数名一样
            // dispatch触发actions 
            
        },

        // 这里面可以获取Vuex当中的mutations和actions方法

        // 需要节流的函数
        // moveIn(index){
        //     console.log(index)
        //     this.currentIndex = index
        // },

        // moveIn:function(index){
        //     console.log(index)
        //     this.currentIndex = index
        // },

         moveIn:throttle(function(index){
            console.log(index)
            this.currentIndex = index
        }, 100,{'trailing': false}),

        toSearch(event){
            // event：事件对象  写了形参就拿到了事件对象  没写就相当于没接收 并不是说没传
            // 事件源  事件目标元素
            // 回调函数: 1.我定义的 2.我没调用 3.它执行了   浏览器/系统执行的

            let target = event.target//代表目标元素 目标元素有可能是a 也有可能不是a
            let data = target.dataset  
            //dataset 拿的就是元素身上以data-开头的所有的值和属性组成的一个对象
            // 但是它自作主张把属性  大写改成了小写  categoryid  categoryname
            console.log(data)

            let {categoryname,category1id,category2id,category3id} = data
            if(categoryname){
                // 代表点的一定是a
                // 如果categoryName是存在的 代表点的一定是a
                // 既然点的是a 那么一定会跳转 所以我们创建跳转的对象
                let location = {
                    name:'search',
                }
                
                // 创建query参数的对象  来收集整理query参数
                let query = {
                    categoryName:categoryname
                }

                if(category1id){
                    query.category1Id = category1id
                }else if(category2id){
                    query.category2Id = category2id
                }else{
                    query.category3Id = category3id
                }

                // 把query参数放到location当中
                location.query = query

                this.$router.push(location)
            }
        }
    },
 
```

* 1.在computed里边把数据捞过来
```
 computed:{
        // 可以去拿Vuex当中的state数据及getters当中的数据
        ...mapState()
    }
在computed里边 ...mapState() 就会自动导入
import { mapState } from 'vuex'

```
* ...mapState(['categoryList']) 它就可以帮你拿到数据
* Vue中找组件 TypeNav
        categoryList:undefined 
        为什么是undefined???

        因为如果vuex使用了模块化开发,就没办法获取state数组使用数组,必须使用对象
#### 1.知识点补充： ...mapState
* 1. 假设我们目前没有使用vuex模块化开发
```
1.本质写法
    categoryList(){
        return this.$store.state.categoryList  //直接从store当中的state中获取这个数据就可以简写为数组
    },
    count(){
        return this.$store.state.categoryList
    },

        /***
         * categoryList 存在总的store的state当中
         * 拿数据的时候: this.$store.state.categoryList 
         * 这样拿数据比较复杂
         * 
         * 提供了一个函数 mapState()
         * 
         */

2.数组 简化写法
 ...mapState(['categoryList','count'])

  /**
     * mapState 是一个方法
     * mapState() 调用函数
     * ...mapState()  在解包
     * ...在解包mapState()这个返回值
     * 
     * 在对象里边用... 返回的必然是对象
     * 返回的对象就是上面的本质写法
     */

3.1对象写法
    // mapState如果用到数组要求名称必须和state当中的名称一致才能正确映射,否则不行
    // 如果想要用自己随意起的名字,那么就要用对象写法

    // 名字如果不同 就用对象写法   没有使用模块化开发

      ...mapState({
            categoryList(){
                return this.$store.state.categoryList
            },
      })

3.2 对象的简化写法
 ...mapState({
        categoryList: state => state.categoryList
        // 在mapState当中,它允许categoryList这个属性直接拿到它(mapState)内部的一个参数 state
        // state是从mapState它的内部来的
        // 这个state可以让你直接获取到你的store当中的state
        // 拿的是总的store当中的state
    })

```
* 2.使用模块化开发
   // 如果vuex使用了模块化开发,就没办法获取state数组使用数组,必须使用对象
```
    ...mapState({
         categoryList: state => state.home.categoryList 
    })
    }
```

#### 2.知识点补充： ...三点运算符
*  ...扩展运算符  它就是用来拆包和打包的
* 打包只有在函数的形参当中会出现,其余都是拆包
* 1.打包  只会打包成数组
* 2.拆包  拆数组  拆对象
        // 如果想要拆对象只有在另外一个对象里边拆  
        // 数组拆出来是它的元素  对象拆出来是它的键值对
        // 对象要拆包必须在另外一个对象当中 去拆 拆的是键值对
```
    <script>
        // 1.打包  只会打包成数组
        function fn(a,b,...arr){
            console.log(arr)// (7) [3, 4, 5, 6, 7, 8, 9]
        }
        fn(1,2,3,4,5,6,7,8,9)
        //  不定参传参 


        // 2.1拆包 拆数组 拆对象
        let arr1 = [1,2,3,4]
        console.log(...arr1) // 1 2 3 4
        let arr2 = [1,2,3,4,...arr1]
        console.log(arr2) // (8) [1, 2, 3, 4, 1, 2, 3, 4]

       console.log( Math.max(...[12,3,5,8]))//12  max边一定要是个数

        // 2.2拆包 拆对象
        let obj = {
            name:'zhaoliying',
            age:33
        }
        // console.log(...obj)// Found non-callable @@iterator  不行这样拆
        // ...运算符和for...of都是需要迭代器的

        let obj2 ={
            ...obj
        }
        console.log(obj2)//{name: "zhaoliying", age: 33}
        // 如果想要拆对象只有在另外一个对象里边拆  
        // 数组拆出来是它的元素  对象拆出来是它的键值对
        // 对象要拆包必须在另外一个对象当中 去拆 拆的是键值对
     </script>
```

### 2.展示数据
* 1.数据结构
        categoryList:Array[17]
                0:Object
                        categoryChild:Array[12]
                                0:Object
                                    categoryChild:Array[4]
                                            0:Object
* 2.三层for循环 遍历数组
        TypeNav  ---- index.vue
    D:\a-尚硅谷-前端\01尚硅谷前端\视频\16-刘渊vue\15-2前台项目\gulishop-client_3\gulishop-client3\src\api\index.js    item 留一个  其他不要
* 3.遍历一级分类 v-for 
        <div class="item" v-for="(c1,index) in categoryList" :key="c1.categoryId">
* 4.展示数据  
        <a href="">{{c1.categoryName}}</a>
* 5.遍历二级分类 v-for
        <dl class="fore" v-for="(c2,index) in c1.categoryChild" :key="c2.categoryId">
* 6.展示数据
        <a href="">{{c2.categoryName}}</a> 
* 7.em 留一个 其他不要
* 8.遍历三级分类 v-for
        <em v-for="(c3,index) in c2.categoryChild" :key="c3.categoryId">
* 9.展示数据
        <a href="">{{c3.categoryName}}</a>

### 3.数据展示完毕,解决小问题
* 1.鼠标悬停在链接上变色，需要修改一下公共样式
        public下的 css下的 reset.css
        a:link:hover  不要link只保留hover

* 2.悬停在分类上背景色需要变化，修改分类组件的样式
        TypeNav --- index.vue
                        &:hover {
                            background-color: hotpink;
                            .item-list {
                                display: block;
                            }
                        }

* 3.三级分类列表宽度比较小，右边的缝隙比较大
        TypeNav --- index.vue
                         dd {
                             float: left;
                             width: 615px;
                             padding: 3px 0 0;
                             overflow: hidden;
                         }

## 20.事件控制23级的显示和隐藏  移入移出改为js来做  
* 1.之前:(不用)  TypeNav---index.vue
                        &:hover {
                            background-color: hotpink;
                            .item-list {
                                display: block;
                            }
                        }
    改为item_on

                    ​	 &.item_on {
                    
                    ​              background-color: hotpink;
                    
                    ​              .item-list {
                    
                    ​                display: block;
                    
                    ​              }
                    
                    ​            }
    
* 2.强制添加类：
                             1.变量(如果现在不知道要表示哪个类) 
                             2.对象(类名固定,但是它显示不显示不知道)  类名生效不生效看数据 true:生效 false:不生效
                             3.数组(一个标签同时有多个类都生效)

* 3.设计数据:
                             移入哪一个一级分类就把哪一个下标赋值给 currentIndex  那么移入的这个下标一定适合currentIndex相等,其余不等 
    ```
      data() {
        return {
            currentIndex:-1
        }
    },
    ```

    ```
     <div class="item" v-for="(c1,index) in categoryList" 
                        :key="c1.categoryId" 
                        :class="{item_on:currentIndex === index}"
                        @mouseenter="currentIndex = index">
    ```

* 4.更改结构  添加已一个外部的div 并给它绑定移出事件 
```
            <div @mouseleave="currentIndex = -1>
                    <h2 class="all">全部商品分类</h2>
                         <div class="sort"></div>
            </div>
```

## 21.演示快速触发事件卡顿现象  浏览器卡了  --- 用防抖和节流(不会导致浏览器卡)
```
@mouseenter="moveIn(index)"

        moveIn(index){
            this.currentIndex = index  这块在做赋值操作,但是你移入太快了,浏览器计算的慢,浏览器卡了
        }
```

### 1.知识点补充  防抖和节流
* 正常执行    100s  执行   100次
* 函数防抖    前面所有的都不执行 , 只有最后一次执行    让正常的次数最后只执行一次   
* 函数节流    100s分成10段    每10s执行一次,其余的不执行  节省流量    少量执行

```
1.时间频繁触发可能造成的问题?
    1).一些浏览器事件: window.onresize 、 window.mousemove等,  触发的频率非常危险,会造成浏览器性能问题
    2).如果向后台发送请求,频繁触发,对服务器造成不必要的压力

2.如何限制事件处理函数频繁调用
    1).函数节流
    2).函数防抖

3.函数节流(throttle)
    1).理解:
        在函数需要频繁触发时:函数执行一次后,只有大于设定的执行时间后才会执行第二次
        适合多次时间按时间做平均分配触发
    2).场景:
        窗口调整(resize)
        页面滚动(scroll)
        DOM元素的拖拽功能实现(mousemove)
        抢购疯狂点击(click)
    
4.函数防抖(debounce)
    1).理解:
        在函数需要频繁触发时:在规定时间内,只让最后一次生效,前面的不生效
        适合多次事件一次响应的情况
    2).场景:
        输入框实时搜索联想(keyup/input)

```

## 23.优化快速触发typeNav鼠标移入和移出事件，节流lodash的throttle节流操作
* lodash 中文
        函数 Function
        _.throttle:节流操作
        _.debounce:防抖操作

* _.throttle
_.throttle(func, [wait=0](时间间隔), [options={(leading(前)|trailing(后))}])
创建一个节流函数
_.throttle 是一个函数,返回的也是一个函数

* 之前下载的包里边有依赖这两个包的 lodash uuid 已经装好了
* lodash.js  所有的功能文件

```
1.需要节流的函数
        moveIn(index){
            console.log(index)
            this.currentIndex = index
        },

2.写法
        moveIn:function(index){
            console.log(index)
            this.currentIndex = index
        },

3.节流的语法
var throttled = _.throttle(renewToken, 300000, { 'trailing': false });

4.函数节流
        moveIn:_.throttle(function(index){
            console.log(index)
            this.currentIndex = index
        }, 100)
```
## 25.解决使用lodash节流后，快速移出后，可能还会显示某个子项
* 加上{'trailing': false} 就ok了,论trailing的重要性！！！！！
* {'trailing': false} 是不让函数在拖延之后执行,也就是在时间间隔内执行完这个函数,如果不写有可能最后一次是拖延执行的
```
  moveIn:_.throttle(function(index){
            console.log(index)
            this.currentIndex = index
        }, 100,{'trailing': false})
```

* 当你想把一个函数改为箭头函数的时候,先看下一函数用有没有this,如果有this就算了,如果非要改也能改,先得保存this,再改;也可以用bind把this指向改了,然后再用

## 26. 引入包的体积过大 按需引入
```
// import _ from 'lodash' //体积过大
import throttle from 'lodash/throttle'


        moveIn:throttle(function(index){
            console.log(index)
            this.currentIndex = index
        }, 100,{'trailing': false})
```

## 27.点击某个类别（无论几级）跳转到搜索页面
* 点击类别的时候  携带两个参数到search页面   需要把点击的 categoryName  categoryId 通过query参数传递过去
* 使用 router-view 和 router-link
*  path:'/search/:keyword?',//?是可传可不传  ！！！！！！ 
* 在三级列表的地方用router-link

### 1.点击类别的时候  携带两个参数到search页面
```
1.字符串 '代表解析js的区域'
<router-link :to="'/search/?categoryName='+c1.categoryName + '&category1Id=' + c1.categoryId" ></router-link> 

2.``拼接符
<router-link :to="`/search/?categoryName=${c1.categoryName}&category1Id=${c1.categoryId}`"></router-link>

3.对象
    一级分类
 <router-link :to="{name:'search',query:{categoryName:c1.categoryName,categoryId:c1.categoryId}}">{{c1.categoryName}}</router-link>
    二级分类
<router-link :to="{name:'search',query:{categoryName:c2.categoryName,categoryId:c2.categoryId}}">{{c2.categoryName}}</router-link>
    三级分类
<router-link :to="{name:'search',query:{categoryName:c3.categoryName,categoryId:c3.categoryId}}">{{c3.categoryName}}</router-link>
```


### 2.卡 电脑风扇开始转了
* router-link 不是html标签 而是组件标签  是router给引进来的
* 写一个组件标签就出现一个组件对象 是通过new 组件对象的构造函数new出来的  
   new Vue.extend({})
* 内存占用过多  效率不高
* 使用声明式导航牵扯到使用组件标签,使用组件标签如果多了
  组件对象非常多,就会造成效率低下(内存占用厉害) 因此我们不能使用声明式导航 采用编程式导航 


## 27.使用编程式路由导航优化声明式导航组件对象过多造成的卡顿  (性能优化的地方) 可以跟面试官唠的
### 1.编程式导航
* 1.让我们自己加功能
* 2.让效率更高
* 使用编程式导航
```
    <a href="javascript:;" @click="$router.push({name:'search',query:{categoryName:c1.categoryName,categoryId:c1.categoryId}})">{{c1.categoryName}}</a>

    <a href="javascript:;" @click="$router.push({name:'search',query:{categoryName:c2.categoryName,categoryId:c2.categoryId}})">{{c2.categoryName}}</a>

    <a href="javascript:;" @click="$router.push({name:'search',query:{categoryName:c3.categoryName,categoryId:c3.categoryId}})">{{c3.categoryName}}</a>

```

### 2. 效率仍然低   回调函数占用内存太多
* 采用编程式导航 每个a标签都是用点击事件,又会导致,事件的回调函数太多
#### 1.事件委派--- 依赖于事件冒泡
* 找离它最近的父元素
* 事件冒泡最终要冒泡到 dom 
* document 初始包含块 ---没有在html用元素表示它们 | html body
* 浏览器的最外层是初始包含块
* 事件流是客观存在的  跟添不添加事件监听没有关系
* 事件委派拿的是距离最近的  分层的  公共的 某一个祖先角色

* <div class="all-sort-list2" @click="toSearch">
```
一级分类
    <a href="javascript:;">{{c1.categoryName}}</a>
二级分类
    <a href="javascript:;">{{c2.categoryName}}</a>
三级分类
    <a href="javascript:;">{{c3.categoryName}}</a>

在每一个a标签上把它的参数存起来  
以data-开头的好处是 它有一个api  后期可以通过api直接拿到参数
一级分类
    <a href="javascript:;" :data-categoryName="c1.categoryName" :data-categoryId="c1.categoryId">{{c1.categoryName}}</a>
二级分类
    <a href="javascript:;" :data-categoryName="c2.categoryName" :data-categoryId="c2.categoryId">{{c2.categoryName}}</a>
三级分类
    <a href="javascript:;" :data-categoryName="c3.categoryName" :data-categoryId="c3.categoryId">{{c3.categoryName}}</a>

```

* 1.你怎么知道你点的是a?

* 2.就算你点的是a,你点的是几级的a？ 因为它们带的参数不一样

    标签的data-开头的属性，叫做自定义属性
	通过我们的标签对象.dataset

* 3.绑定事件
  
     <div class="all-sort-list2" @click="toSearch">
     
* 4.toSearch()

     <div class="all-sort-list2" @click="toSearch">
```
     toSearch(event){
            // event：事件对象  写了形参就拿到了事件对象  没写就相当于没接收 并不是说没传
            // 事件源  事件目标元素
            // 回调函数: 1.我定义的 2.我没调用 3.它执行了   浏览器/系统执行的

            let target = event.target//代表目标元素 目标元素有可能是a 也有可能不是a
            let data = target.dataset  
            //dataset 拿的就是元素身上以data-开头的所有的值和属性组成的一个对象
            // 但是它自作主张把属性  大写改成了小写  categoryid  categoryname
            console.log(data)

            let {categoryname,category1id,category2id,category3id} = data
            if(categoryname){
                // 代表点的一定是a
                // 如果categoryName是存在的 代表点的一定是a
                // 既然点的是a 那么一定会跳转 所以我们创建跳转的对象
                let location = {
                    name:'search',
                }
                
                // 创建query参数的对象  来收集整理query参数
                let query = {
                    categoryName:categoryname
                }

                if(category1id){
                    query.category1Id = category1id
                }else if(category2id){
                    query.category2Id = category2id
                }else{
                    query.category3Id = category3id
                }

                // 把query参数放到location当中
                location.query = query

                this.$router.push(location)
            }
        }
   
```

# day04
## 30.搜索页的typeNav一级列表隐藏
* Search页的三级分类列表一上来要隐藏   既然要隐藏 后续一移上去肯定要出来  证明页面在变化  既然页面在变化  一定有数据控制
* TypeNav 用到了两次 一个是在 Home页  一个是在 Search页
* 跳到Search页  TypeNav这个组件相当于重新加载了一次

### 1.设计数据
* TypeNav   index.vue
```
 data() {
        return {
            currentIndex:-1,
            isShow:true
        }
```
### 2.把 isShow 给三级分类添加
```
 <div class="sort" v-show="isShow">

```

### 3.在mounted中 挂载完成后就判断
```
在 Home 页一上来就是true   当一上来就跳转到 Search页就是隐藏  把isShow改为false

 怎么知道 TypeNav是在  home页还是在Search页呢？
 通过路由去判断  

   mounted(){
        // 挂载完成后(模板挂载完成后,模板变成真正的dom后)

        // 为了判断TypeNav组件是在home页还是在search页  如果是search页那么我们要首先隐藏三级分类列表
        if(this.$route.path !== '/home'){
            this.isShow = false
        }

        this.getCategoryList()
    },
```
### 4.移入显示  移出隐藏
* 移入到全部商品分类外部的div  显示三级分类列表
```
<div @mouseleave="currentIndex = -1" @mouseenter="moveInDiv">

        moveInDiv(){
            this.isShow = true
        },
```

* 把原来的移出事件变成了回调函数
```
<div @mouseleave="moveOutDiv" @mouseenter="moveInDiv">   

        // 移出全部商品分类的div , 隐藏search三级分类列表,home当中隐藏二三级分类
        moveOutDiv(){
            // 隐藏二三级分类
            this.currentIndex = -1 
            
           // 为了判断TypeNav组件是在home页还是在search页  如果是search页那么我们要首先隐藏三级分类列表
            if(this.$route.path !== '/home'){
                this.isShow = false//隐藏search的全部三级分类
            }
        },
```

## 31.显示和隐藏一级列表的过渡效果添加 
 Vue 
    风格指南 
        过渡&动画
        
* 1.谁变就给谁加transition  也就是说给 v-show 加transition
```
         <transition name="show">
                <div class="sort" v-show="isShow"></div>
         </transition>

    .sort 下边
                &.show-enter{
                    opacity: 0;
                    height: 0;
                }

                &.show-enter-active{
                    transition: all 3s;
                }

                &.show-enter-to{
                    opacity: 1;
                    height: 461px;
                }
```
* 可以给.sort 改颜色

# 32.优化typeNav数据ajax请求次数，改变请求的位置
* 在home页发送一次ajax请求  点击跳转到search页又发送了一次ajax请求 
* 由于数据都是一样的  所以没必要发送两次ajax请求拿数据

* 怎么减少发请求的次数
* 发请求的地方在哪里?  当时写在了TypeNav的mounted 当中
```
  mounted(){
        // 挂载完成后(模板挂载完成后,模板变成真正的dom后)

        // 为了判断TypeNav组件是在home页还是在search页  如果是search页那么我们要首先隐藏三级分类列表
        if(this.$route.path !== '/home'){
            this.isShow = false
        }

        this.getCategoryList()
    },
```
```
也就是说发请求的地方写错了  
TypeNav 它是个组件  这个组件在home里边用了一次  在search里边用了一次
在home创建的时候 TypeNav要创建一次  mounted就要执行一次 
到了search页组件一切换   home里边的死了
而search里边又要去创建这个组件    mounted就又执行一次

路由组件的切换会导致生命周期的distroy  一切换会销毁
TypeNav 首先在home当中 
一到home当中  home被创建  TypeNav 这个组件就要被创建一次  创建一次发送一次请求  拿到数据
拿到数据  展示数据
home展示完了之后 又点击了一下类别 跳转到search页
search和home发生切换,一旦切换  home就被销毁掉了  就去到了search页来了
而search页当中又用了一下TypeNav  而TypeNav又要重新创建一次 
重新创建一次  它的mounted又要重新执行一次  所以它的get又重新发送了一次请求 
但是home页发送的请求和search页发送的请求  请求的数据是一样的  没必要发两次
发一次就可以了  就是发送的位置不对  放在App.vue中发请求就可以了

因为App.vue只创建一次
```
放在TypeNav.vue这里会发送多次请求 
而请求的数据是一样的 (home和search都会发)  挪到App当中发请求  同时把发请求的函数拿过去
```
App.vue

  mounted() {
    this.getCategoryList() 
  },
  methods:{
    // 函数定义也要定义在这里

        getCategoryList(){
            // 用户在触发相应的actions去发请求拿数据
            this.$store.dispatch('getCategoryList') //名字刚好和函数名一样
            // dispatch触发actions 
            
        },
  }
```

# 33.合并分类的query参数和搜索关键字的params参数
* 需求:点击三级分类任何一个类别 跳到 Search页 带的是query参数
* 需求:在搜索框中搜索 点击搜索跳转到search页 带的是params参数
components
        Header 
            index.vue  搜索在这里

```
1.
let location ={
                name:'search',
                params:{keyword:this.keyword || undefined},
                // query:{keyword2:this.keyword.toUpperCase()}
            };

2.在router ---- index.js  注释掉不要了
 props(route){
                // route是接受完参数的路由对象
                return {
                    // 自己映射
                    // 把路由对象接收到的参数,无论什么参数,自己手动映射为路由组件的属性
                    keyword:route.params.keyword, 
                    keyword2:route.query.keyword2
                }
            }

在header里边只带来一个params参数过去

1.点击三级分类列表中带的参数   search?categoryName=手机
2.点击搜索带的就是搜索的关键字  aa
3.点击类别和点击搜索  合并这两个参数
    跳转到search页就两种方式
        1.点击分类  带的是query参数  search?categoryName=手机
        2.点击搜索  带的是params参数  aa

    点击搜索的时候判断路径当中有没有query参数  有的话带上
    点击类别的时候判断路径当中有没有params参数  有的话带上

    要处理的就是  
        1.点击搜索按钮的toSearch方法 
        2.点击类别的toSearch方法

        Header --- > index.vue
            // 判断当前路由当中是不是有query参数 , 有就带上   有的话说明先点击的类别 后点击的搜索按钮
            let {query} = this.$route  
            if(query){
                location.query = query
            }
    
        TypeNav --- index.vue
            
                // 判断当前路由当中是不是有params参数 , 有就带上   有的话说明先点击的类别 后点击的搜索按钮
                let {params} = this.$route  
                if(params){
                    location.params = params
                }

合并参数: 华为?categoryName=厨具
```

# 35.使用mockjs来模拟数据接口（其实和ajax差不多，mock其实就是给我们的json数据指定一个url路径去做请求）
* 想要 mock数据 本地要有数据
* 真正的接口 数据在后端的服务器上  数据本身存在数据库的表里边
* 后端没有给我们接口,但是我们还想像真正发请求拿数据那样这样的过程
    虽然这个数据是本地的,但是它和我们直接用这个数据是两码事
    如果你本地的数据没有经过mock    mock(模拟数据接口)
    mock数据之后,虽然这个数据是在本地,但是这个数据是动态的数据
    如果这个数据没有经过mock,直接使用 这个数据值静态的数据  是假的
    mock数据也要发请求  但是这个请求还没有发送到后端的时候就被拦截了
    拦截到前端那块  
    自己给自己发请求 然后自己把自己本地的数据返回去 
    mock 自己发请求问自己要数据

### 1.设计数据  而且数据必须是json
* 因为后端返回来的数据本身就是json
* 你给自己发请求也要准备成json 要不然不认识
* 通过一个模块实现模拟接口

*  1.准备数据
src
    mock
        banner.json
        floor.json

        接口  课件(2.14 mock/模拟数据接口)

#### 1.banner.json
```
[
    {
        "id":"1",
        "imgUrl":"/images/banner1.jpg"
    },
    {
        "id":"2",
        "imgUrl":"/images/banner2.jpg"
    },
    {
        "id":"3",
        "imgUrl":"/images/banner3.jpg"
    },
    {
        "id":"4",
        "imgUrl":"/images/banner4.jpg"
    }
]
```
* json 前端要求要么是对象  要么是数组

#### 2.floor.json
```
[{
        "id": "001",
        "name": "家用电器",
        "keywords": ["节能补贴", "4K电视", "空气净化器", "IH电饭煲", "滚筒洗衣机", "电热水器"],
        "imgUrl": "/images/floor-1-1.png",
        "navList": [{
                "url": "#",
                "text": "热门"
            },
            {
                "url": "#",
                "text": "大家电"
            },
            {
                "url": "#",
                "text": "生活电器"
            },
            {
                "url": "#",
                "text": "厨房电器"
            },
            {
                "url": "#",
                "text": "应季电器"
            },
            {
                "url": "#",
                "text": "空气/净水"
            },
            {
                "url": "#",
                "text": "高端电器"
            }
        ],
        "carouselList": [{
                "id": "0011",
                "imgUrl": "/images/floor-1-b01.png"
            },
            {
                "id": "0012",
                "imgUrl": "/images/floor-1-b02.png"
            },
            {
                "id": "0013",
                "imgUrl": "/images/floor-1-b03.png"
            }
        ],
        "recommendList": [
            "/images/floor-1-2.png",
            "/images/floor-1-3.png",
            "/images/floor-1-5.png",
            "/images/floor-1-6.png"
        ],
        "bigImg": "/images/floor-1-4.png"
    },
    {
        "id": "002",
        "name": "手机通讯",
        "keywords": ["节能补贴2", "4K电视2", "空气净化器2", "IH电饭煲2", "滚筒洗衣机2", "电热水器2"],
        "imgUrl": "/images/floor-1-1.png",
        "navList": [{
                "url": "#",
                "text": "热门2"
            },
            {
                "url": "#",
                "text": "大家电2"
            },
            {
                "url": "#",
                "text": "生活电器2"
            },
            {
                "url": "#",
                "text": "厨房电器2"
            },
            {
                "url": "#",
                "text": "应季电器2"
            },
            {
                "url": "#",
                "text": "空气/净水2"
            },
            {
                "url": "#",
                "text": "高端电器2"
            }
        ],
        "carouselList": [{
                "id": "0011",
                "imgUrl": "/images/floor-1-b01.png"
            },
            {
                "id": "0012",
                "imgUrl": "/images/floor-1-b02.png"
            },
            {
                "id": "0013",
                "imgUrl": "/images/floor-1-b03.png"
            }
        ],
        "recommendList": [
            "/images/floor-1-2.png",
            "/images/floor-1-3.png",
            "/images/floor-1-5.png",
            "/images/floor-1-6.png"
        ],
        "bigImg": "/images/floor-1-4.png"
    }
]
```
* JSON js抽象的一个对象  js中独有的 
    里边有两个方法 
        stringify  JSON.stringfy() 把一个对象或一个数组变成json
        parse      JSON.parse() 把一个json反序列化成一个对象或是一个数组
        序列化和反序列化
* json json数据格式

#### 2.floor.json
```
[{
        "id": "001",
        "name": "家用电器",
        "keywords": ["节能补贴", "4K电视", "空气净化器", "IH电饭煲", "滚筒洗衣机", "电热水器"],
        "imgUrl": "/images/floor-1-1.png",
        "navList": [{
                "url": "#",
                "text": "热门"
            },
            {
                "url": "#",
                "text": "大家电"
            },
            {
                "url": "#",
                "text": "生活电器"
            },
            {
                "url": "#",
                "text": "厨房电器"
            },
            {
                "url": "#",
                "text": "应季电器"
            },
            {
                "url": "#",
                "text": "空气/净水"
            },
            {
                "url": "#",
                "text": "高端电器"
            }
        ],
        "carouselList": [{
                "id": "0011",
                "imgUrl": "/images/floor-1-b01.png"
            },
            {
                "id": "0012",
                "imgUrl": "/images/floor-1-b02.png"
            },
            {
                "id": "0013",
                "imgUrl": "/images/floor-1-b03.png"
            }
        ],
        "recommendList": [
            "/images/floor-1-2.png",
            "/images/floor-1-3.png",
            "/images/floor-1-5.png",
            "/images/floor-1-6.png"
        ],
        "bigImg": "/images/floor-1-4.png"
    },
    {
        "id": "002",
        "name": "手机通讯",
        "keywords": ["节能补贴2", "4K电视2", "空气净化器2", "IH电饭煲2", "滚筒洗衣机2", "电热水器2"],
        "imgUrl": "/images/floor-1-1.png",
        "navList": [{
                "url": "#",
                "text": "热门2"
            },
            {
                "url": "#",
                "text": "大家电2"
            },
            {
                "url": "#",
                "text": "生活电器2"
            },
            {
                "url": "#",
                "text": "厨房电器2"
            },
            {
                "url": "#",
                "text": "应季电器2"
            },
            {
                "url": "#",
                "text": "空气/净水2"
            },
            {
                "url": "#",
                "text": "高端电器2"
            }
        ],
        "carouselList": [{
                "id": "0011",
                "imgUrl": "/images/floor-1-b01.png"
            },
            {
                "id": "0012",
                "imgUrl": "/images/floor-1-b02.png"
            },
            {
                "id": "0013",
                "imgUrl": "/images/floor-1-b03.png"
            }
        ],
        "recommendList": [
            "/images/floor-1-2.png",
            "/images/floor-1-3.png",
            "/images/floor-1-5.png",
            "/images/floor-1-6.png"
        ],
        "bigImg": "/images/floor-1-4.png"
    }
]
```

* json 串里边都是双引号没有单引号

#### 3.建一个文件
mock
    mockServer.json

* 安装 mock.js
    npm install -S mockjs

* mockServer.js
```
// 这个文件才是正儿八经的去把数据模拟接口去获取
// 模拟接口使用一个包 mock.js

import Mock from 'mockjs'
import banner from '@/mock/banner' 
import floor from '@/mock/floor'

// Mock 是一个对象 它有一个方法 mock  
Mock.mock('/mock/banner',{code:200,data:banner}) //就是用来 把数据和路径注册为接口
Mock.mock('/mock/floor',{code:200,data:floor})

// mock  数据
// 1.准备数据
// 2.准备路径
// 3.把数据和路径注册成为一个接口
// 4.安装mockjs
// 5.导入数据后 用的是Mock下的mock()去注册的
// 6.切记在main.js当中运行这个接口
```

* main.js
```
 import '@/mock/mockServer' //运行 这个文件 让mock可以注册上接口

```

* 发请求
ajax
    mockAjax.js
```
//这个文件对应的是发送请求获取mock的数据使用的axios
//用这个文件当中是axios发请求不会发送给后端
//因为mock会拦截这个ajax请求,因此我们在network当中看不到发送的这个ajax请求
//但是最后我们的数据确实是请求获取到的(在前端请求本地获取的)


import axios from 'axios'
import NProgress from 'nprogress' //相当于导入了js <script src='nprogress.js'></script>
import 'nprogress/nprogress.css' //引入css

/**
        1.配置基础路径和超时限制

		2.添加进度条信息  nprogress

		3.返回的响应不再需要从data属性当中拿数据，而是响应就是我们要的数据

		4.统一处理请求错误, 具体请求也可以选择处理或不处理
  
 */

// 1.配置基础路径和超时限制
const instance = axios.create({
    baseURL: '/mock',//配公共路径  请求路径当中公共的路径
    timeout: 20000,
  });

  // mock数据在前端拦截Ajax请求

// 2.添加进度条信息  nprogress
/**
 * 用到请求拦截器和响应拦截器
 * 
 * 请求拦截器:
 *          1.可以在请求时候添加功能
 *          2.我们可以对请求报文进行处理
 * 
 * 响应拦截器:
 *          1.可以添加功能
 *          2.可以处理响应报文信息
 * 
 * 找到Interceptors
 * 只需要把axios换成instance
 * create创建出来的其实就相当于一个新的axios
 * 
 * 用到一个插件 nprogress
 * 
 * 1.用到 nprogress 中的js和css
 * <script src='nprogress.js'></script>
 * <link rel='stylesheet' href='nprogress.css'/>
 * 
 * 2.安装 nprogress
 * 安装 $ npm install --save nprogress
 * 
 * 3.最终要用的
 * NProgress.start();  请求拦截器中开始
 * NProgress.done();   响应拦截器中结束
 * 
 * 
 * 
 */

//  在请求拦截器中不需要写失败的回调---发请求失败了没意义
instance.interceptors.request.use( config => {
    // config就是你的请求报文对象,可以这么理解
    /**
     *  1.可以在请求时候添加功能
     *  2.我们可以对请求报文进行处理
     */
    NProgress.start();//添加进度条功能

    return config;//一定要把config返回去
  })


//   3.返回的响应不再需要从data属性当中拿数据，而是响应就是我们要的数据

instance.interceptors.response.use(
    response => {
        NProgress.done();
        return response.data;
  }, 
    error => {
        NProgress.done();
    //   4.统一处理请求错误, 具体请求也可以选择处理或不处理
    alert('发送ajax请求失败'+error.message || '未知错误')
    // 错误了之后可以选择今后可以继续处理这个错误,也可以选择今后不能处理这个错误

    //  return Promise.reject(error);//返回的是失败的promise,是可以让后续继续处理这个错误的
    //  如果不想让他处理  中断Promise链 返回一个pending状态的promise
    return new Promise(()=>{})
  }
)

// 暴露出去
export default instance
```

* 	mock会拦截我们的ajax请求，不会真正去发送请求。（发送请求是往本地发的，没有往后端发，请求的数据也是本地的）
* 但是他有一个发送请求获取数据的过程

* 1.需要建一个mock文件夹,在这个文件夹需要准备数据,而且本地数据需要是json格式
* 2.需要在mock文件夹中再建一个文件 mockServe.js
    这个mockServer.js才是正儿八经去模拟接口用的
    它需要用到一个包,叫做mockjs
    这个mockjs可以导出一个对象  Mock
    这个对象里边有一个方法 叫mock()
    是用来注册接口的  可以把一个路径以及你的数据注册成为一个接口
    到时候往这里发请求就可以了

* 3.拿数据
    1.在ajax里边专门为mock发请求创建一个ajax  mockAjax.js
    
* 4.拿的数据是在 ListContainer 和 Floor 用的
    1.api接口

api --- index.js
```
import mockAjax from '@/ajax/mockAjax' 

export const reqBannerList = () => {
    return mockAjax({
        url:'/banner',
        method:'get',
    })
}

export const reqFloorList = () => {
    return Ajax({
        url:'/floor',
        method:'get'
    })
}
```

* 5.一旦写好接口请求函数  接下来就是Vuex了
    发送请求 拿数据  数据要有地方存

    写一个api --- > 写store

* 6.store ---> home.js
```
import {reqCategoryList,reqBannerList,reqFloorList} from '@/api' //引入接口请求函数  并把main中测试的给删掉

import {reqCategoryList,reqBannerList,reqFloorList} from '@/api' //引入接口请求函数  并把main中测试的给删掉

// 存数据的地方,多个属性的对象
// 3.把数据存起来
const state = {
    categoryList:[] ,  //初始化存储的共享状态数据 
    bannerList:[],
    floorList:[]
}
// RECEIVECATEGORYLIST 这个函数一触发给state里边保存数据

// 直接修改数据的地方,是多个方法的一个对象   方法当中不能出现  if for 异步操作
// 2.提交给mutations修改数据
const mutations = {
    // mutations当中的函数名都是要大写的
    RECEIVECATEGORYLIST(state,categoryList){
        state.categoryList = categoryList
    },
    // 有人commit的时候RECEIVECATEGORYLIST这个函数才会执行

    RECEIVEBANNERLIST(state,bannerList){
        state.bannerList = bannerList
    },

    RECEIVEFLOORLIST(state,floorList){
        state.floorList = floorList
    }
}

// 和用户对接的地方,也是多个方法的一个对象  可以出现 if for 异步操作
// 1.发请求 用户dispatch
const actions = {
    async getCategoryList({commit}){
        const result = await reqCategoryList()
        //调用这个函数相当于在调api中的这个函数 它会返回一个Ajax最后的调用结果 它的调用结果是一个Promise
        // 想要拿数据就.then 但是我们用async await

        if(result.code === 200){
            commit('RECEIVECATEGORYLIST',result.data)
            // 提交给响应的mutations去修改相应的数据
        }
    },

    async getBannerList({commit}){
        // context 是Vuex 的上下文对象  本质是store对象
        // 在context的内部除了有 commit还有state dispatch mutations actions
        const result = await reqBannerList()

        if(result.code === 200){
            commit('RECEIVEBANNERLIST',result.data)
        }
    },

    async getFloorList({commit}){
        const result = await reqFloorList()

        if(result.code === 200){
            commit('RECEIVEFLOORLIST',result.data)
        }
    }
}
// actions当中发请求拿数据commit
// 当用户一旦dispactch它 getCategoryList就发请求

// 通过state计算出来的属性数据(只有读没有写,只能使用state数据,不能修改state数据)
const getters = {}


export default {
    state,
    mutations,
    actions,
    getters
}

// 三连环写完之后没有发请求 如果用户没有dispatch 它是不可能发请求的
//  一旦用户dispatch 三连环就被触发了  数据自然而然就存储到Vuex里边了  组件里边没有
// banner 和 floor 里边的数据在 home页中的 listContainer里边 和 floor里边用到了

```

### 2.拿数据
page
    Home
        ListContainer
            index.vue   在这里边拿数据

```
 mounted(){
        this.getBannerList()
    },
    methods: {
        getBannerList(){
            this.$store.dispatch('getBannerList')
        }
    },
```



* 在mounted 当中发请求 拿数据  发送异步请求
* beforeDestroy 做一系列收尾工作
* 每一次发请求 都要用一个函数 可以复用

* 在network看不到mock的数据发送的请求  在vuex里边看
* FloorList 并不是在 Floor中去拿 而是在 Home中去拿
    因为Floor是两个东西  是要用v-for遍历的 到时候只写一个
    v-for要根据数据遍历

* 在Home ---> index.vue中拿数据
```
 mounted(){
        this.getFloorList()
    },
    methods:{
        getFloorList(){
            this.$store.dispatch('getFloorList')
        }
    }
```

## 36.mock数据的随机语法
* 生成随机语法,拦截 Ajax 请求
* 拦截Ajax请求  : 真正的Ajax请求是发不出去的  它直接就在前端拦截了,是发送不到后端去的
    它发送请求了,用的是mockAjax
    但是真正看不到这个请求 因为拦截了

## 37.从Vuex中捞取数据到Vue中进行展示
* 1.ListContainer ---> index.vue
     computed:{
        ...mapState({
            // 这里不能用数组 因为它不在总的store里边 而是在home的store里边  只有在总的store里边才能用数组
           bannerList: state => state.home.bannerList 
        })
    }

    在Vue里边的  ListContainer 看有没有拿到数据

* 2.展示数据
    ListContainer --- > index.vue
                        <div class="swiper-wrapper">
                            <div class="swiper-slide" v-for="(banner,index) in bannerList" :key="banner.id">
                                <img :src="{{banner.imgUrl}}" />
                            </div>
                        </div>

    数据没了。。。。。。
    因为 src="/images/banner1.jpg"
    mockjs全部都是在根下边找这个图片的  都是拼接在/下边的
    当一旦用来mock数据  相应的图片应该放到 public里边
    public
        images
        把ListContainer里边的banner1-4 剪切放到 public的images中

* 3.Home ---> index.vue
```
1.
    computed:{
        ...mapState({
            floorList:state => state.home.floorList
        })
    }

    在 Vue里边的 Home 看有没有 FloorList的数据

2.
        <Floor  v-for="(floor, index) in floorList" :key="floor.id" :floor="floor"></Floor>
        <!-- 
            组件间通信 在父组件当中通过属性传递给某一个子组件
            props组件间通信
                适用场合:父子之间
                如果父亲给儿子传的是非函数数据,那么本质是父亲在给儿子传数据,让儿子用的
                如果父亲给儿子传的是函数数据,其实本质是父亲在接收儿子给他的数据
                    它其实是让儿子调这个函数,儿子在调用这个函数的时候可以传实参
                    这个函数在父组件当中定义的,父组件当中可以接收到儿子传递过来的实参
                    
                    
         -->
        <!-- <Floor></Floor> -->

3.在 Floor ---> index.vue中接收属性
  props:['floor'],//声明接收属性  根据属性就能拿到属性值
    // 接收的是传进来的属性
```

* 4.展示数据
```
1.
<h3 class="fl">{{floor.name}}</h3>

2. li 留一个
                            <li class="active" v-for="(nav,index) in floor.navList" :key="nav.text">
                                <a href="#tab1" data-toggle="tab">{{nav.text}}</a>
                            </li>

3. li留一个  节能补贴

  <ul class="jd-list">
        <li v-for="(keyword,index) in floor.keywords" :key="index">{{keyword}}</li>
                                   
 </ul>
 <img :src="floor.imgUrl" />

 4.
 <div class="swiper-slide" v-for="(carouse,index) in floor.carouselList" :key="carouse.id">
    <img :src="carouse.imgUrl">
 </div>


 5.

                            <div class="split">
                                <span class="floor-x-line"></span>
                                <div class="floor-conver-pit">
                                    <img :src="floor.recommendList[0]" />
                                </div>
                                <div class="floor-conver-pit">
                                    <img :src="floor.recommendList[1]" />
                                </div>
                            </div>
                            <div class="split center">
                                <img :src="floor.bigImg" />
                            </div>
                            <div class="split">
                                <span class="floor-x-line"></span>
                                <div class="floor-conver-pit">
                                    <img :src="floor.recommendList[2]" />
                                </div>
                                <div class="floor-conver-pit">
                                    <img :src="floor.recommendList[3]" />
                                </div>
                            </div>
```
* Property or method "carouselList" is not defined on the instance but referenced during render. Make sure that this property is reactive, either in the data option, or for class-based components, by initializing the property.

少写了个 floor.
```
 <div class="swiper-slide" v-for="(carouse,index) in floor.carouselList" :key="carouse.id">
    <img :src="carouse.imgUrl"/>
</div>
```

## 38.实现页面轮播
* swiper 官网
    点击  开始使用swiper
    1.首先加载插件，需要用到的文件有swiper-bundle.min.js和swiper-bundle.min.css文件
    现在更新到swiper6
    一会使用swiper5

    2.把 HTML内容放到ListContainer里边  banner 一样
```
<div class="swiper-container">
    <div class="swiper-wrapper">
        <div class="swiper-slide">Slide 1</div>
        <div class="swiper-slide">Slide 2</div>
        <div class="swiper-slide">Slide 3</div>
    </div>
    <!-- 如果需要分页器 -->
    <div class="swiper-pagination"></div>
    
    <!-- 如果需要导航按钮 -->
    <div class="swiper-button-prev"></div>
    <div class="swiper-button-next"></div>
    
    <!-- 如果需要滚动条 -->
    <div class="swiper-scrollbar"></div>
</div>
```


* 重要
* swiper 在实例化的时候一定要等到页面结构形成之后再去 new
* script 最好放到body 最下边去写  ---保证结构已经解析完成,然后再去解析js
* swiper要求html结构必须形成完成,然后再去new swiper才能生效
* 必须在结构形成以后,再去实例化swiper

### 1.安装swiper
* 直接 npm i swiper -S 安装的是最新版本
* 我们要装 5 版本
* npm i swiper@5 就会装5版本    swiper@5.4.5

### 2.banner 轮播图   ListContainer ---> index.vue
* 1.引入 js 和 css
* search node_modules     快捷键 : Ctrl+Shift+P  
* 2.引入js和css
    import Swiper from 'swiper'
    import 'swiper/css/swiper.min.css'
* 3.在官网上拿 4.初始化Swiper
```
<script>        
  var mySwiper = new Swiper ('.swiper-container', {
    direction: 'vertical', // 垂直切换选项
    loop: true, // 循环模式选项
    
    // 如果需要分页器
    pagination: {
      el: '.swiper-pagination',
    },
    
    // 如果需要前进后退按钮
    navigation: {
      nextEl: '.swiper-button-next',
      prevEl: '.swiper-button-prev',
    },
    
    // 如果需要滚动条
    scrollbar: {
      el: '.swiper-scrollbar',
    },
  })        
  </script>

```
复制到mounted当中
```
new Swiper ('.swiper-container', {
    loop: true, // 循环模式选项
    
    // 如果需要分页器
    pagination: {
      el: '.swiper-pagination',
    },
    
    // 如果需要前进后退按钮
    navigation: {
      nextEl: '.swiper-button-next',
      prevEl: '.swiper-button-prev',
    },
  })        
```
* 4.
```
  <div class="swiper-container" ref="bannerSwiper">

  setTimeout(() => {
      new Swiper(this.$refs.bannerSwiper, {
        loop: true, // 循环模式选项

        // 如果需要分页器
        pagination: {
          el: ".swiper-pagination",
        },

        // 如果需要前进后退按钮
        navigation: {
          nextEl: ".swiper-button-next",
          prevEl: ".swiper-button-prev",
        },
      });
    }, 3000);

```
* 此时上边的大轮播能正常  但是下边的小茶壶不能点  两个的轮播相互不影响
*  虽然说延迟定时器可以解决这个问题但是不好

### 3.ListContainer --- index.vue
* watch + nextTick
```
//   监视
  // 一般监视bannerList
  watch: {
    // 一般监视和深度监视
    // 监视bannerList

    // 只要这个对象里边只有一个配置项handler , 就可以简写为函数形式
    // 函数形式是没有深度监视的写法的
    // bannerList(){
    //      new Swiper(this.$refs.bannerSwiper, {
    //       loop: true, // 循环模式选项

    //       // 如果需要分页器
    //       pagination: {
    //         el: ".swiper-pagination",
    //       },

    //       // 如果需要前进后退按钮
    //       navigation: {
    //         nextEl: ".swiper-button-next",
    //         prevEl: ".swiper-button-prev",
    //       },
    //     });
    // },

    bannerList: {
      // 配置对象

      handler() {
        // 监视哪个数据变化之后所执行的函数
        // 现在监视的bannerList,一旦bannerList发生变化,它就会执行handler()这个回调
        // 如果这个对象里边只写了handler,那它就是一般监视
        // 发请求  0---4  这个变化

        // 监视:有变化才执行
        // watch:监视  有这个数据监视就可以了    有这个数据监视你来干其他的活
        // 只要是用监视这个数据一定存在   只是它里边的值可能有变化
        // 根据一个已有的数据,我们监视它来干其他的事情用watch
        // watch:监视  这个数据一定存在,根据这个数干另外的事情
        // 你的变化会导致另外一件事的发生

        // computed:计算 没有这个数据你要用就要计算  没有这个值,要通过已有的数据做计算
        // 根据一个已有的数据,计算出来一个要用的没有的数据
        // 我的页面上需要这个数据,但是此时我没有
        //  没有这个数据,但是我想用这个数据  那就要根据已有的数据计算出这个要用的数据

        // 放在这里能保证bannerList内部一定有数据 , 但是还是不能保证结构完全形成
        // new Swiper的时候能保证4张图片已经存在了

        //  this.$nextTick() 等待页面最近一次的更新完成之后再去执行它内部的回调
        // nextTick是一个回调  它里边又传了一个回调
        // 当数据从0-4改变了之后执行 nextTick
        // updated:不管第几次更新只要是有更新就执行
        // nextTick:页面dom最近一次更新会执行  之后的更新就不会执行了

        this.$nextTick(() => {
            // 这个回调是nextTick的回调,nextTick会等待页面dom最近一次循环更新结束之后才会执行它内部传递的回调
            // updated也可以实现,但是并不是最新一次更新,而是所有的更新都会执行这个钩子(updated)
          new Swiper(this.$refs.bannerSwiper, {
            loop: true, // 循环模式选项

            // 如果需要分页器
            pagination: {
              el: ".swiper-pagination",
            },

            // 如果需要前进后退按钮
            navigation: {
              nextEl: ".swiper-button-next",
              prevEl: ".swiper-button-prev",
            },
          });
        });
      },
    },
  },

  // 深度监视bannerList
  // watch:{
  //     // 一般监视和深度监视
  //     // 监视bannerList
  //     // 深度监视就是在监视的对象里边写  deep:true,
  //     bannerList:{
  //         deep:true,
  //         // 配置对象
  //         handler(){
  //             // 监视哪个数据变化之后所执行的函数
  //             // 现在监视的bannerList,一旦bannerList发生变化,它就会执行handler()这个回调
  //             // 如果这个对象里边只写了handler,那它就是一般监视
  //         }
  //     }

  // }

  // 一般监视和深度监视的区别:
  // 现在bannerList里边是一个数组,假设数组里边有两个对象  [{a:'b'},{a:'c'}]
  // 一般监视监视的bannerList, 也就是说他监视的是整个数组
  // 往数组里边加一个对象  [{a:'b'},{a:'c'},{a:'d'}]  一般监视是可以监视到的 因为这个数组发生了变化
  // 或者说删除数组里边的一个对象,他也是能够监视到的[{a:'b'}]

  // 但是如果说  [{a:'b'},{a:'c'}]  把数组中第一个属性的值改成了e [{a:'e'},{a:'c'}]
  // 整个数组发生了变化  , 因为对象中的值发生了变化 , 代表数组中的值页发生了改变
  // 但是一般监视监视不到 监视不到内部的对象的属性值的改变
  // 一般监视监视不到数组当中对象的属性值发生变化,它只能监视数组有没有增加或减少
  // 或者说把数组中的对象换成了另外一个对象他也是能监视到的  [{c:'b'},{a:'c'}] 这样也是可以监视到的
  // 但是如果说数组当中对象的某一个属性值发生改变  一般监视监视不到

  // 一般监视:只能监视数组本身数据的改变,而不能监视数组内部对象内部属性的变化
  // 深度监视:用来解决一般监视解决不了的问题
  // 如果加了  deep:true
  // 即使是改数组当中对象中的每个属性的值 也是可以监视到的
```

## 一般监视和深度监视
```
//   监视
// 一般监视bannerList
watch:{
    // 一般监视和深度监视
    // 监视bannerList

    bannerList:{
        // 配置对象
        handler(){
            // 监视哪个数据变化之后所执行的函数
            // 现在监视的bannerList,一旦bannerList发生变化,它就会执行handler()这个回调
            // 如果这个对象里边只写了handler,那它就是一般监视
        }
    }

},

// 深度监视bannerList
watch:{
    // 一般监视和深度监视
    // 监视bannerList
    // 深度监视就是在监视的对象里边写  deep:true,
    bannerList:{
        deep:true,
        // 配置对象
        handler(){
            // 监视哪个数据变化之后所执行的函数
            // 现在监视的bannerList,一旦bannerList发生变化,它就会执行handler()这个回调
            // 如果这个对象里边只写了handler,那它就是一般监视
        }
    }

}

// 一般监视和深度监视的区别:
// 现在bannerList里边是一个数组,假设数组里边有两个对象  [{a:'b'},{a:'c'}]
// 一般监视监视的bannerList, 也就是说他监视的是整个数组
// 往数组里边加一个对象  [{a:'b'},{a:'c'},{a:'d'}]  一般监视是可以监视到的 因为这个数组发生了变化
// 或者说删除数组里边的一个对象,他也是能够监视到的[{a:'b'}]

// 但是如果说  [{a:'b'},{a:'c'}]  把数组中第一个属性的值改成了e [{a:'e'},{a:'c'}]  
// 整个数组发生了变化  , 因为对象中的值发生了变化 , 代表数组中的值页发生了改变
// 但是一般监视监视不到 监视不到内部的对象的属性值的改变
// 一般监视监视不到数组当中对象的属性值发生变化,它只能监视数组有没有增加或减少
// 或者说把数组中的对象换成了另外一个对象他也是能监视到的  [{c:'b'},{a:'c'}] 这样也是可以监视到的
// 但是如果说数组当中对象的某一个属性值发生改变  一般监视监视不到

// 一般监视:只能监视数组本身数据的改变,而不能监视数组内部对象内部属性的变化
// 深度监视:用来解决一般监视解决不了的问题
// 如果加了  deep:true  
// 即使是改数组当中对象中的每个属性的值 也是可以监视到的
```

## watch 和 computed
```
 // 监视:有变化才执行
        // watch:监视  有这个数据监视就可以了    有这个数据监视你来干其他的活
        // 只要是用监视这个数据一定存在   只是它里边的值可能有变化
        // 根据一个已有的数据,我们监视它来干其他的事情用watch
        // watch:监视  这个数据一定存在,根据这个数干另外的事情
        // 你的变化会导致另外一件事的发生

        // computed:计算 没有这个数据你要用就要计算  没有这个值,要通过已有的数据做计算
        // 根据一个已有的数据,计算出来一个要用的没有的数据
        // 我的页面上需要这个数据,但是此时我没有  没有这个数据,但是我想用这个数据  那就要根据已有的数据计算出这个要用的数据
```

## $nextTick
* Vue官网
    API
        Vue.nextTick  --- Vue代表构造函数
        vm.$nextTixk ---- Vue 的实例上的方法
* 功能一样
* vm.$nextTick([callback])
* 将回调延迟到下次DOM更新循环之后再执行
* // updated:不管第几次更新只要是有更新就执行
* // nextTick:页面dom最近一次更新会执行  之后的更新就不会执行了

## 生命周期
```
  <script>

    new Vue({
      data:{
        isShow:true
      },
      //生命周期钩子执行的顺序是固定的

     1.  beforeCreate ---- 初始化前  vm创建前  vm生成前   打印数据是看不见的
      beforeCreate() {
        //打印数据是看不见的
        console.log(this.isShow)//undefined
      },

    <!-- 数据代理   数据监视 --> 源码
    this是vm  如果没有数据代理 , vm身上根本就没有isShow

     2.created ---- 初始化后  vm创建后      vm生成后       打印数据是可以看见了
      created() {
        //打印数据可以看见
        console.log(this.isShow)//true
      },

     3.beforeMount ---- 挂载前  模板挂在前
      beforeMount() {
        //挂在前，模板挂在前（生成正儿八经的标签）
        console.log(this.$refs.pp)//undefined  根本就没有p标签
      },

     4.mounted ---- 挂载后   模板挂在后   数据的初始化解析之后 compiler 模板解析完成以后才把模板挂载到挂载点下边去  就真正生成了dom元素了
      mounted() {
        console.log(this.$refs.pp) //可以打印出来  此时代表p已经生成正儿八经的标签了
        //回调代码一般都在这  发ajax  定时器
        this.timer = setInterval(() => {
          this.isShow = !this.isShow
        }, 1000);
      },

     5.beforeUpdate ----  vm当中的数据都已经被改了,但是页面上的数据没变   页面更新前(页面上的数据是错的)
      beforeUpdate() {
        console.log(this.isShow,this.$refs.pp.innerText)
      },

    <!-- 页面更新 -->

     6.updated ---- vm当中的数据都已经被改了,但是页面上的数据已经变了  页面更新后
      updated() {
        console.log(this.isShow,this.$refs.pp.innerText)
      },


   
    7.beforeDestroy ----
      beforeDestroy() {
        // 一般是在销毁实例之前的一些善后工作 清除定时器，解绑事件等相关
        clearInterval(this.timer)
      },

     <!-- 销毁必须调用vm的destroy方法 -->

     8.destroyed ----
      destroyed() {
        //销毁后可以打印提示信息
        console.log('销毁了')
      },
      methods: {
        destroy(){
          //点击按钮我要销毁vm实例，销毁之前自动会调用beforeDestroy回调
          this.$destroy() //销毁实例的方法，固定的
        }
      },
    }).$mount('#root')
  </script>
```

## 42.动态显示Floor组件
* Floor中的轮播图
* Floor
    index.vue

### 1.引入css 和 js
```
import Swiper from "swiper";
import "swiper/css/swiper.min.css";
```
### 2.swiper
```
<div class="swiper-container" ref="floorSwiper">


 mounted() {
    //   为什么floorSwiper放mounted中就可以,而bannerSwiper放mounted中就不行呢?
    // 就看结构是否形成了
    // floor的数据是在home里边拿的,是在home里边获取的floorList这个数据
    // 在遍历floor的时候船舰<Floor></Floor>这个组件的时候mounted才会走
    // 拿一个数据创建这个<Floor></Floor>组件就会执行mounted
    // 而这个数据早都已经通过<Floor  v-for="(floor, index) in floorList" :key="floor.id" :floor="floor"></Floor>
    // :floor="floor" 传过去了
    // 不需要发请求获取数据,这个数据相当于<floor></floor>组件自己的数据

    // 为什么Floor组件就能直接在mounted当中实例化我们的swiper,因为swiper在实例化的时候
    // Floor当中的结构已经形成,原因是floor当中没有发请求拿数据的过程,而是数据本身就已经存在

    
    new Swiper(this.$refs.floorSwiper, {
      loop: true, // 循环模式选项

      // 如果需要分页器
      pagination: {
        el: ".swiper-pagination",
      },

      // 如果需要前进后退按钮
      navigation: {
        nextEl: ".swiper-button-next",
        prevEl: ".swiper-button-prev",
      },
    });
  },

```

### 3.把ListContainer和Floor中swiper的部分封装成一个单独的组件去使用
* 1.Floor 中的Swiper
```
 watch: {
    floor: {
      handler() {
        this.$nextTick(() => {
          new Swiper(this.$refs.floorSwiper, {
            loop: true, // 循环模式选项

            // 如果需要分页器
            pagination: {
              el: ".swiper-pagination",
            },

            // 如果需要前进后退按钮
            navigation: {
              nextEl: ".swiper-button-next",
              prevEl: ".swiper-button-prev",
            },
          });
        });
      },
    },
  },

```

* 2.ListContainer 里的Swiper
```
 watch: {
    bannerList: {
      handler() {
        this.$nextTick(() => {
          new Swiper(this.$refs.bannerSwiper, {
            loop: true, // 循环模式选项

            // 如果需要分页器
            pagination: {
              el: ".swiper-pagination",
            },

            // 如果需要前进后退按钮
            navigation: {
              nextEl: ".swiper-button-next",
              prevEl: ".swiper-button-prev",
            },
          });
        });
      },
    },
  },

```

* bannerList中的Swiper显示正常,但是Floor中的Swiper不能正常显示
* Floor中的数据本身就是Floor中的数据,监视watch 3-3  根本就没有变化
* 没有变化,handler就不会执行
* nextTick就更想了

* 3.即使没有变化也要执行一遍
* immediate:true,//无论怎么样,必须立即执行一次handler回调
```
  watch: {
    floor: {
        immediate:true,//无论怎么样,必须立即执行一次handler回调
      handler() {
        this.$nextTick(() => {
          new Swiper(this.$refs.floorSwiper, {
            loop: true, // 循环模式选项

            // 如果需要分页器
            pagination: {
              el: ".swiper-pagination",
            },

            // 如果需要前进后退按钮
            navigation: {
              nextEl: ".swiper-button-next",
              prevEl: ".swiper-button-prev",
            },
          });
        });
      },
    },
  },

```

```
 watch: {
    immediate:true,//添加这个东西没意义,只是让两边的代码保持一致
    bannerList: {
      handler() {
        this.$nextTick(() => {
          new Swiper(this.$refs.bannerSwiper, {
            loop: true, // 循环模式选项

            // 如果需要分页器
            pagination: {
              el: ".swiper-pagination",
            },

            // 如果需要前进后退按钮
            navigation: {
              nextEl: ".swiper-button-next",
              prevEl: ".swiper-button-prev",
            },
          });
        });
      },
    },
  },

```

* 4.抽取公共的代码形成公共组件
* 代码里边一样  结构一样
* 遍历的东西不一样
* 抽取成为一个公共组件,当它创建这个组件的时候,传入不同的数据就可以了
* components
    SlideLoop
        index.vue
            js代码/html结构--- 组件
            通过组件间通信传递数据
* 注册

* 拿 html 和js (watch)
* 在main.js 中引入  全局注册
```
import SliderLoop from '@/components/SliderLoop'
Vue.component('SliderLoop',SliderLoop)

```

* components  
    SliderLoop
        index.vue
```
<template>
<!-- 拿swiper里边的结构 -->
        <!--banner轮播-->
        <div class="swiper-container" ref="bannerSwiper">
          <div class="swiper-wrapper">
            <div
              class="swiper-slide"
              v-for="(banner, index) in bannerList"
              :key="banner.id"
            >
              <img :src="banner.imgUrl" />
            </div>
          </div>
          <!-- 如果需要分页器 -->
          <div class="swiper-pagination"></div>

          <!-- 如果需要导航按钮 -->
          <div class="swiper-button-prev"></div>
          <div class="swiper-button-next"></div>
        </div>
</template>

<script>
import Swiper from "swiper";

export default {
    name:'SliderLoop',
    props:['bannerList'],
    watch: {
   
    bannerList: {
       immediate:true,//添加这个东西没意义,只是让两边的代码保持一致
      handler() {
        this.$nextTick(() => {
          new Swiper(this.$refs.bannerSwiper, {
            loop: true, // 循环模式选项

            // 如果需要分页器
            pagination: {
              el: ".swiper-pagination",
            },

            // 如果需要前进后退按钮
            navigation: {
              nextEl: ".swiper-button-next",
              prevEl: ".swiper-button-prev",
            },
          });
        });
      },
    },
  },
}
</script>

<style lang="less" scoped>
    
</style>
```
* <SlideLoop :bannerList="floor.carouselList"></SlideLoop>
* <SliderLoop :bannerList="bannerList"></SliderLoop>

# day05
## 47.search接口测试和编写请求函数 （参数按照文档的给定）
* 不需要拆分组件了
* 1.Search路由静态
    把里边的 images  SearchSelector  index.vue 直接ctrl+c ctrl+v 复制到之前写好的search中  替换当前目标文件
    src
        pages
            Search
                替换当前目标文件
* 此时search页的静态页面就已经完成了

* 子组件
    SearchSelector   是Search组件的子组件
    组件是为了共用、复用  让结构更加清晰
    这是专门的一个选择的模块

    品牌
    属性  --- 平台属性  (是为了搜索东西而用的)

* 点击某一个图片去到它的详情页  详情页里边还有一个属性叫做销售属性(是用来买东西的)

* 2.展示动态数据
    发请求
        1.api  接口请求函数
        2.接口请求函数写好后 要发请求  --- 就要存数据(vuex)
        3.看接口请求文档 
            api接口文档  4.搜索商品
    拿数据
    展示数据

* axios 
    params参数
    query参数
    请求体参数
```
axios:{
    url:            /params?key=value
    methods:
    data:  //请求体参数
    params: //query参数  也可以写在url后边 以?隔开  
}

真正的params参数只能写在url里边,以/开始
```
* 请求体参数 最终的data要求是一个对象

### 3.写接口请求函数  reqGoodsListInfo
* 1.api ---> index.js
```
// 请求获取search的商品列表数据   --- 列表页
// /api/list
// POST
// data 请求体参数
// 返回一个对象  {}
/*
{
    "category3Id": "61",
    "categoryName": "手机",
    "keyword": "小米",
    "order": "1:desc",
    "pageNo": 1,
    "pageSize": 10,
    "props": ["1:1700-2799:价格", "2:6.65-6.74英寸:屏幕尺寸"],
    "trademark": "4:小米"
  }
  */
// searchParams 代表的是搜索参数  如果搜索参数里边什么都没有 只是一个空对象也没问题
// 返回的是所有的商品信息
// 如果搜索参数当中有东西 那么返回的就是按照这些参数搜索到的商品信息
// 至少要传一个空对象{}  不传是undefined 会报错的
// 我们测试的时候可以使用空对象去作为参数发请求   但是不能不传递参数,不传递就相当于没有传递参数,因为它传的是undefined
  export const reqGoodsListInfo = (searchParams) => {//函数中必须要传一个参数 
    return Ajax({
        url:'/list',
        method:'POST',
        data:searchParams //必须是一个对象
    })
  }

//   测试接口
//   切记传一个空对象
//   在main.js中引入
  reqGoodsListInfo({}) 

//   Network 里边   list
```
* 2.测试接口 main.js
    import '@/api'

* 3.查看Network
    list
        goodsList

* 如果 code 是201 表示请求确实成功了,但是参数错误


### 2.vuex 
* 发请求 拿数据 存储
#### 1.store ---> search.js
* 三连环 
```
import { reqGoodsListInfo } from "@/api"

const state = {
    goodsListInfo:{},
    /**
     * 什么时候用数组？什么时候用对象？在哪看
     * 在api接口文档中看返回的data
     * 看data是 [] / {}
     */
}

const mutations = {
    RECEIVEGOODSLISTINFO(state,goodsListInfo){
        state.goodsListInfo = goodsListInfo
    }
}

 const actions = {
    // searchParams 搜索参数 是根据用户的指定而来的
    // 用户指定了搜索参数之后再去分发、触发进行发送请求
    // 搜易这个参数是用户传过来的
    async getGoodsListInfo({commit},searchParams){
        const result = await reqGoodsListInfo(searchParams)

        if(result.code === 200){
            commit('RECEIVEGOODSLISTINFO',result.data)
        }
    }
}

// 现在请求还没发,需要在组件当中发请求
const getters = {}

export default {
    state,
    mutations,
    actions,
    getters
}
```

* 写完三连环请求还没发,需要在组件(Search--->index.vue)中发请求

#### 2.Search ---> index.vue
* 1.在mounted中发请求
* 2.在 methods里边定义请求的方法
* 3.在data中初始化数据
```
{
    "category3Id": "61",
    "categoryName": "手机",
    "keyword": "小米",
    "order": "1:desc",
    "pageNo": 1,
    "pageSize": 10,
    "props": ["1:1700-2799:价格", "2:6.65-6.74英寸:屏幕尺寸"],
    "trademark": "4:小米"
  }
```

* 2.Search ---> index.vue
```
 data() {
      return {
        // 初始化的搜索参数 --- 用户有可能搜索的全部参数  默认的东西全部写好 不默认的东西全部清空
        searchParams:{
          // 这个searchParams是用户初始化搜索状态数据,有可能发送的请求参数全部包含,只不过大部分都是空的
            category1Id: "",
            category2Id: "",
            category3Id: "",
            categoryName: "",
            keyword: "",
            props: [],
            trademark: "",

            // 代表的是用户发送请求默认的参数 默认获取第几页  默认排序规则是啥 默认每一页个数
            order: "1:desc",
            pageNo: 1,
            pageSize:2 ,

         }
      }
    },
    mounted(){
      // 发请求在mounted里边发
      this.getGoodsListInfo()
    },
    methods:{
      getGoodsListInfo(){
        // 这次触发actions的时候需要传递搜索参数  它是一个对象
        this.$store.dispatch('getGoodsListInfo',this.searchParams)
      }
    },
```

* 查看请求有没有发   -----》 在 Vuex 中查看
* RECEIVEGETGOODSLISTINFO
* search:Object
* goodsListInfo:Object
* goodsList:Array[2]
* 0:Object
```
attrs:null
category1Id:null
category1Name:null
category2Id:null
category2Name:null
category3Id:null
category3Name:null
createTime:null
defaultImg:"http://182.92.128.115:8080/group1/M00/00/0E/rBFUDF7JrzqATmqQAAJMcb-7-8U325.png"
hotScore:0
id:126
price:4000
title:" iPhone11--11"
tmId:null
tmName:null
```

## 50.search组件动态显示（先不搜索，获取数据去动态展示）
* 把已经拿到vuex中的数据拿到vue当中展示
* 1.展示 子组件 SearchSelector 中的数据
* 2.展示列表页商品的数据

* 尽量避免 a.b.c 
* 因为出现a.b.c 很有可能报一个假错
    虽然页面不受影响,但是 Console 里边会报假错

#### 1.getters
* RECEIVEGOODSLISTINFO
* search:Object
    goodsListInfo:Object
        attrsList:Array[0]
        goodsList:Array[2]
        trademarkList:Array[4]
* 计算出上边看到的三个数组

* 1.在store ---> search.js ---> getters
```
const getters = {
    attrsList(state){
        return state.goodsListInfo.attrsList || []
        /**
         * 能拿到就拿到,拿不到就[] 不至于是undefined  后期再点就报错
         * 一定能拿到数组,即使是空数组,页面也不会报错
         */
    },
    goodsList(state){
        return state.goodsListInfo.goodsList || []
    },
    trademarkList(state){
        return state.goodsListInfo.trademarkList || []
    }
    /**
     * 有可能拿不到东西 拿到的是一个undefined
     * 原因:
     *      1.发请求
     *      2.异步操作
     *      总会有时间的延迟
     * 因为计算的很快  
     * 但是goodsListInfo有没有不知道
     */
}

```

* 2.Search  --- > index.vue
```
1.
    computed:{
      ...mapGetters(['attrsList','goodsList','trademarkList'])
    },

2.
    computed:mapGetters(['attrsList','goodsList','trademarkList']),

3.
    // 原始写法  跟state里边一样
    computed:{
        attrsList(){
          return this.$store.getters.attrsList
        }
    }
    /**
     * mapGetters(['attrsList','goodsList','trademarkList'])
     * 不解包 出来就是一个对象  但是只能写一行
     * 
     * 最终返回的是对象
     * ... 在解包一个对象  
     * 只是把 {} 里边的键值对解包放在了computed里边 
     */
```

* 3.数据有没有拿到 --- 找vue
* Vue 
    Search
        attrsList:Array[0]
        goodsList:Array[2]
        trademarkList:Array[4]
* 数据有了就可以展示数据了
* 4.Search ---> index.vue
```
    computed:mapGetters(['goodsList']),//父组件当中只需要拿到商品列表去展示
    // attrsList  trademarkList 这两个数据是子组件需要展示的,到子组件当中去获取,可以避免组件间通信
    // 组件间通信 能不通尽量不要通  一通信效率低了
    // 组件间通信是需要传输过程的

    /**
     * attrsList
     * trademarkList
     * 
     * 这两个数据不用在这里拿,Search ---> index.vue 相当于父组件 
     * 而这两个数据是在子组件中展示的,如果在这里拿的话会涉及到组件间通信
     * 
     */
```

* 5.有了数据,就可以在父组件当中显示这个数据了
```
1.Search ---> index.vue
    detail
        goods-list
            li --- 留一个

 <li class="yui3-u-1-5" v-for="(goods,index) in goodsList" :key="goods.id">
                <div class="list-wrap">
                  <div class="p-img">
                    <a href="item.html" target="_blank">
                      <!-- <img src="./images/mobile01.png" /> -->
                        <img :src="goods.defaultImg"/>
                      </a>
                  </div>
                  <div class="price">
                    <strong>
                      <em>¥</em>
                      <i>{{goods.price}}</i>
                    </strong>
                  </div>
                  <div class="attr">
                    <a 
                    target="_blank" 
                    href="item.html" 
                    title="促销信息，下单即赠送三个月CIBN视频会员卡！【小米电视新品4A 58 火爆预约中】"
                    >{{goods.title}}</a>
                  </div>
                  <div class="commit">
                    <i class="command">已有<span>2000</span>人评价</i>
                  </div>
                  <div class="operate">
                    <a href="success-cart.html" target="_blank" class="sui-btn btn-bordered btn-danger">加入购物车</a>
                    <a href="javascript:void(0);" class="sui-btn btn-bordered">收藏</a>
                  </div>
                </div>
              </li>
```

* 6.bread  面包屑

* 7.SearchSelector  获取 attrsList trademarkList 数据
* SearchSelector.vue
```
import { mapGetters } from 'vuex'
  export default {
    name: 'SearchSelector',
    computed:{
      ...mapGetters(['attrsList','trademarkList'])
    }
  }
```

* 8.展示品牌列表
    1.展示品牌 
        li 留一个
```
<ul class="logo-list">
          <li v-for="(trademark,index) in trademarkList" :key="trademark.tmId">{{trademark.tmName}}</li>
</ul>
```

#### 属性的展示  双层for循环
* !!!! attrsList:Array[0]
##### 2.展示数据
* attrList 的结构 
attrList:Array[4]
      0:Object
            attrId:2179
            attrName:'型号'
            attrValueList:Array[1]
               0:"MAX"
* 至少是一个双层for循环
```
1.type-wrap 留一个遍历
2.ul 里边的li留一个遍历
 <div class="type-wrap" v-for="(attr,index) in attrsList" :key="attr.attrId" >
      <div class="fl key">{{attr.attrName}}</div>
      <div class="fl value">
        <ul class="type-list">
          <li v-for="(attrValue, index) in attr.attrValueList" :key="index">
            <a>{{attrValue}}</a>
          </li>
        </ul>
      </div>
      <div class="fl ext"></div>
    </div>
```

## 51.根据分类和关键字进行搜索，解决在search组件内部再进行搜索的bug
* 不管是根据分类还是根据关键字 搜索跳转到 search 页面,它的参数都是在路由当中的
* /华为?categoryName=手机
* 怎么去做搜索呢？
```
1.在 Search ---> index.vue 中发的请求
  在mounted发请求之前  就应该把路由当中的参数拿到
  并且赋值给 searchParams , 然后它就会发请求了
```
    data() {
      return {
        // 初始化的搜索参数 --- 用户有可能搜索的全部参数  默认的东西全部写好 不默认的东西全部清空
        searchParams:{
          // 这个searchParams是用户初始化搜索状态数据,有可能发送的请求参数全部包含,只不过大部分都是空的
            category1Id: "",//query参数变化的搜索参数
            category2Id: "",//query参数变化的搜索参数
            category3Id: "",//query参数变化的搜索参数
            categoryName: "",//query参数变化的搜索参数
            keyword: "",//params参数变化的搜索参数
            props: [],//按照平台属性搜索的参数
            trademark: "",//按照品牌搜索 参数

            // 代表的是用户发送请求默认的参数 默认获取第几页  默认排序规则是啥 默认每一页个数
            order: "1:desc",
            pageNo: 1,
            pageSize:2 ,

         }
      }
    },
    // 根据类别和关键字进行搜索,其实本质就是在mounted之前,把相关的参数给拿到,赋值给我们的searchParams,然后请求
    beforeMount(){
      // 请求是在mounted当中发的,在发请求之前应该把路由当中所携带的params参数或者query参数拿到,然后赋值给searchParams
      // 我们可以从路由当中获取所需要的query参数和params参数
      // 传递的参数如果是undefined,代表没传   如果传递的参数是'',其实是真的有参数,但是其实没必要传递空串的参数
      // 把参数是空串的人全部过滤掉
      let {category1Id,category2Id,category3Id,categoryName} = this.$route.query
      let {keyword} = this.$route.params

      // 如果一个对象当中有同名的属性,后面的会把前面的覆盖掉
      let searchParams = {
        ...this.searchParams,
        category1Id,
        category2Id,
        category3Id,
        categoryName,
        keyword
      }

      // 过滤空串
      Object.keys(searchParams).forEach(item => {
        if(searchParams[item] === ''){
          delete searchParams[item]
        }
      })
      //  Object.keys() --- 最终拿的是属性名组成的数组

      this.searchParams = searchParams
      // 此时的searchParams 已经修改了

    },
 
```

```
* Request Payload 中    category1Id没有传回来的原因                            
<a href="javascript:;" :data-categoryName="c1.categoryName" :data-category1Id="c1.categoryId">{{c1.categoryName}}</a>
<a href="javascript:;" :data-categoryName="c2.categoryName" :data-category2Id="c2.categoryId">{{c2.categoryName}}</a>
<a href="javascript:;" :data-categoryName="c3.categoryName" :data-category2Id="c3.categoryId">{{c3.categoryName}}</a>

* 按照类别搜索
  category1Id: "2"
  categoryName: "手机"
* 按照关键字搜索
  keyword: "华为"

### 2. bug:
* 1.在home页的搜索框中写aa,跳转到search后,出现一个页面,而在search页的搜索框中再次搜索bb,页面没有反应
* 2.在home页点击分类跳转到search页,出现一个也买你,而在search页再次点击分类,页面页没有反应
* 整个页面没反应,但是地址栏中的路径变了
* watch  监视已经存在的数据

* 3.原因
* beforemount和mounted 只执行一次
  因为组件已经创建了,在搜索框中写bb只是改了参数
  并没有切换组件,mounted就不会执行第二次,而请求是在mounted中发的,所以不会再次发请求
* 想办法让mounted发请求

* 4.Search ---> index.vue
```
  watch: {
    // $route就是当前组件对象的数据
    $route: {
      // 监视里边可以获取两个数据  第一个是新值:newVal; 第二个是旧值:oldVal
      handler(newVal, oldVal) {
        let {
          category1Id,
          category2Id,
          category3Id,
          categoryName,
        } = this.$route.query;
        let { keyword } = this.$route.params;

        // 如果一个对象当中有同名的属性,后面的会把前面的覆盖掉
        let searchParams = {
          ...this.searchParams,
          category1Id,
          category2Id,
          category3Id,
          categoryName,
          keyword,
        };

        // 过滤空串
        Object.keys(searchParams).forEach((item) => {
          if (searchParams[item] === "") {
            delete searchParams[item];
          }
        });
        //  Object.keys() --- 最终拿的是属性名组成的数组

        this.searchParams = searchParams;
        // 此时的searchParams 已经修改了

        this.getGoodsListInfo();

        /**
            拿参数
            整理参数
            重新赋值给searchParams
            重新发请求
         */
      },
    },
  },

```
* 这样就可以随意切换params和query参数重新发请求了
* 如何在一个路由组件当中重复的发请求 --- 一定要用到watch的
* 因为发请求本身在mounted里边,而这个路由组件如果不切换,mounted只能走一次
* 其实在search页面重复发送请求,只能通过监视watch
* 监视当前的路由对象
* 因为mouted在路由组件当中不切换的情况下只会执行一次

* 简化重复代码----封装函数
* 5.在methods里边封装函数
```
    handlerSearchParams(){
      let {
          category1Id,
          category2Id,
          category3Id,
          categoryName,
        } = this.$route.query;
        let { keyword } = this.$route.params;

        // 如果一个对象当中有同名的属性,后面的会把前面的覆盖掉
        let searchParams = {
          ...this.searchParams,
          category1Id,
          category2Id,
          category3Id,
          categoryName,
          keyword,
        };

        // 过滤空串
        Object.keys(searchParams).forEach((item) => {
          if (searchParams[item] === "") {
            delete searchParams[item];
          }
        });
        //  Object.keys() --- 最终拿的是属性名组成的数组

        this.searchParams = searchParams;
        // 此时的searchParams 已经修改了
    }
  
```

* 在beforeMount和watch中直接调用
this.handlerSearchParams()
```
watch: {
    // $route就是当前组件对象的数据
    $route: {
      // 监视里边可以获取两个数据  第一个是新值:newVal; 第二个是旧值:oldVal
      handler(newVal, oldVal) {
        this.handlerSearchParams()
      }
    }
}
```
### 3.面包屑 bread
* Search --- index.vue
```
  <ul class="fl sui-tag">
            <li class="with-x" v-show="searchParams.categoryName">{{searchParams.categoryName}}<i>×</i></li>
            <li class="with-x" v-show="searchParams.keyword">{{searchParams.keyword}}<i>×</i></li>
          </ul>
```
* 点击 x 删掉 重新发请求
```
1.给x绑定点击事件
     <ul class="fl sui-tag">
            <li class="with-x" v-show="searchParams.categoryName">{{searchParams.categoryName}}<i @click="removeCategoryName">×</i></li>
            <li class="with-x" v-show="searchParams.keyword">{{searchParams.keyword}}<i @click="removeKeyword">×</i></li>
          </ul>
```
2.定义函数 
```
1.search ---> index.vue

   // 点击bread面包屑当中的 x  删除参数当中的categoryName,重新发送请求
    removeCategoryName(){
      this.searchParams.categoryName = null
      this.getGoodsListInfo();
    },
    // 点击bread面包屑当中的 x 删除参数当中的keyword重新发送请求
    removeKeyword(){
      this.searchParams.keyword = null
      this.getGoodsListInfo();
    }
  
```
* keyword:null
```
// 点击bread面包屑当中的 x  删除参数当中的categoryName,重新发送请求
    removeCategoryName(){
      // this.searchParams.categoryName = null
      this.searchParams.categoryName = undefined
      this.getGoodsListInfo();
    },
    // 点击bread面包屑当中的 x 删除参数当中的keyword重新发送请求
    removeKeyword(){
      // this.searchParams.keyword = null
      this.searchParams.keyword = undefined
      this.getGoodsListInfo();
    }
```
* 面包屑 点击x把x前边的内容删掉了,但是路由中却还有
```
 // 点击bread面包屑当中的 x  删除参数当中的categoryName,重新发送请求
    removeCategoryName(){
      // this.searchParams.categoryName = null
      this.searchParams.categoryName = undefined
      // 把params参数给剁了,她里边没有query参数了 id就没必要要了  但是它还有params参数
      // 只需要带上params就可以了

      // this.handlerSearchParams()  //这样写不行
      // 本质是路由当中那个参数还在
      // this.getGoodsListInfo();
      // 虽然可以发请求,但是路径当中的参数不会被删除,因为路由当中国的参数是没变化的,所以我们必须自己手动跳转路由,修改路由当中的参数


      // 先把它路由中的参数改了,然后再让他发请求
      this.$router.push({name:'search',params:this.$route.params})
      // 从当前路由再往自己的路由跳转一次
      // 重新跳转一下路由,然后把原来的参数给删掉
      // 这样一跳转相当于路由变化了,路由一变化,它就会自动发请求
      // 为什么会自动发请求,因为下边有watch
    },
    // 点击bread面包屑当中的 x 删除参数当中的keyword重新发送请求
    removeKeyword(){
      // this.searchParams.keyword = null
      this.searchParams.keyword = undefined
      // this.handlerSearchParams() //这样写不行
      // this.getGoodsListInfo();

      this.$router.push({name:'search',query:this.$route.query})

    }
  
```

## 54.解决删除关键字后，输入框没有更新输入的bug
* 搜索的输入框再Header组件
* 而我们现在是在Search组件
* Header和search之间是兄弟关系
* 兄弟关系之间的通信方式: 全局事件总线


* 1.main.js
```
new Vue({
  beforeCreate() {
    Vue.prototype.$bus = this  
    //在Vue的原型上添加了一个属性 这个属性就是$bus
    // $bus指向了一个对象,而这个对象就是我们的vm对象
    // 它是往Vue的原型身上添加了一个对象

    // 1.为什么要在Vue的原型上添加?
    // 让所有的组件对象都能看到它,找到它  (本质)
    // 组件对象原型的原型就是vm的原型
    // 所以说要把$bus添加到Vue的原型上,而这个Vue的原型就是vm的原型
    // 只不过Vue的原型我们称为显式原型
    // 而vm是Vue实例化出来的对象,
    // 而Vue的显式原型和vm的隐式原型是一个东西

    // 条件一:这个对象必须能让所有的对象都能找到,否则做不了总线

    // 2.事件总线对象必须能够使用$on和$emit这两个方法
    //  如果不能使用这两个方法,全局事件总线不能绑定事件,不能触发事件

    // ? $on 和 $emit 在哪?
    // 这两个方法在 Vue 的原型上
    // 也就是说你所用的这个对象必须能找到Vue的原型上的这两个方法,能调用
    

    // 事件总线能用谁?
    // vm   /    
  },
  el:'#app',
  render: h => h(App),
  router,//router是配置对象的属性 不能改  
  // 配置对象是属性名固定,属性值不固定的对象
  // 让所有的组件当中都可以多两个对象  $router 和 $ route  
  // $router路由器对象  和  $route路由对象
  store,//让所有的组件当中都可以多一个对象  this.$store

  // components:{
  //   App:App  //上面导入的App是定义组件所需的配置对象
  // },
  // template:'<App/>'
})
```

* 2.Search  --- > index.vue
```
  // 点击bread面包屑当中的 x 删除参数当中的keyword重新发送请求
    removeKeyword(){
      // this.searchParams.keyword = null
      this.searchParams.keyword = undefined
      // this.handlerSearchParams() //这样写不行
      // this.getGoodsListInfo();

      // 点击x关闭 通知Header组件,让它把它的搜索框中的东西清一下  
      // 因为输入框中的东西keyword式定义在Header里边的
      // 通知Header组件把输入框中的keyword清空
      this.$bus.$emit('clearKeyword')
      // $on : 绑定事件监听 谁里边用了$on 谁里边想要接收数据  回调函数就留在谁里边
      // $emit :本质上是在发送数据    有就发  没有就触发这个事件 
      // 触发这个事件 clearKeyword 这个事件在Header里边 index.vue里边绑定的

      this.$router.push({name:'search',query:this.$route.query})

    }
  
```

* 3.Header ---> index.vue
```
 mounted(){
        this.$bus.$on('clearKeyword',this.clearKeyword)
        // 谁里边在用$on 回调函数就留在谁里边
        // 回调函数留在谁里边,谁一定在接收数据
    },


 clearKeyword(){
            this.keyword = ''
        }
```

## ！！！全局事件总线
* 1.全局事件总线的条件(两个条件):
    1)必须让所有的组件对象(包括vm)都能找到  --- 放到Vue的原型上/vm的原型上
    2)这个对象必须能使用$on和$emit
* 2.全局事件总线本质是一个对象
* 随意的一个对象不能作为全局事件总线去使用
  没有事件的方法:$on $emit

## 55.根据品牌搜索（设置和删除）
* 需要把Search --- index.vue 里边的 data 里边的trademark设置一个值,然后发请求拿数据
* 1.在父中绑定事件 Search ---> index.vue
```
 <SearchSelector @searchForTrademarke="searchForTrademarke" />
```
* 2.回调函数留在父中  
```
  // 子向父传递品牌数据,按照品牌搜索
    searchForTrademarke(trademark){
      this.searchParams.trademark = trademark
      this.getGoodsListInfo()
    },
```

* 3.子  searchSelector.vue
```
<li v-for="(trademark,index) in trademarkList" :key="trademark.tmId" @click="$emit('searchForTrademark',trademark)">{{trademark.tmName}}</li>

```

* 4.点击品牌看一下有没有
console.log(trademark)
```
{__ob__: Observer}
tmId: (...)
tmName: (...)
```


## 56.根据属性搜索（设置和删除）








