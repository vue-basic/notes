day08

39、vue-router

	是什么
		是vue官方的一个插件
		专门用来实现一个SPA应用
		基于vue的项目基本都会用到此库

		vuex  vue-router  这两个插件应用很广泛




	
	单页Web应用（single page web application，SPA）
		整个应用只有一个完整的页面（这个完整的页面，由多个组件组成）

		点击页面中的链接不会刷新页面, 本身也不会向服务器发请求

		当点击路由链接时, 只会做页面的组件切换（过程当中mounted发ajax请求异步获取数据），然后局部更新（组件切换）

		数据都需要通过ajax请求获取, 并在前端异步展现


		ajax发请求  有自己请求的路径（真实的后端给的接口路径）
		





	路由
		是一个key:value的映射关系

		前台路由   路径 和 要显示的组件
		{

			path:'/home',
			component:Home

		}
		当点击链接的时候，路径会发生变化，但是不会向服务器发请求，而是去显示对应的组件	






		
		后台路由   路径 和 匹配的函数

		app.get('/users/info',function(){})

		当点击链接的时候，路径会发生变化，而且会向服务器发请求，然后匹配到后端的一个函数处理这个路由的请求，返回需要的
		数据





	简单理解前台路由：路由可以让我们实现组件的切换和跳转：
			点击链接，匹配路由，显示对应的组件







	怎么做	
		安装vue-router插件
		路由器的安装和暴露
		注册路由器  Vue当中去注册
		注册路由器的作用
			//注册路由器，注册之后 
 		 	//每个路由组件内部都可以通过this.$router拿到路由器对象
  			//每个路由组件内部都可以通过this.$route拿到当前的路由对象





		1、拆分页面定义组件
			路由组件和非路由组件
			
			//宏观上去看  如果一个组件是点击链接之后才会出现的，那么就一定和路由相关，就被路由组件

			//一个组件是在路由器中的路由中注册的，就是路由组件
			//一个组件不是在路由中注册的就叫非路由组件

		2、定义路由（路由中注册组件）：
			定义对应路由： 映射关系  path和组件（组件在路由当中注册）
			在路由器当中定义路由，每个路由都是一个对象，内部是一个路径和对应显示的组件
				


				
		3、使用路由实现组件切换
			router-link    路由链接，就是点哪，可以让你的路径变为你指定的 to

			router-view    路由组件显示区域，就是组件需要在哪显示




		4、二级路由的使用
			拆分路由组件
			定义子路由
			使用路由实现组件切换





	路由传参： 
		第一步：路由链接组件传数据给路由,     通过路由连接当中的路径传递的
		第二步：路由传数据给显示的路由组件，  默认把路由对象给了路由组件，路由组件内部就可以从路由对象当中获取数据

		1、	最原始的传参
				参数：params参数和路径一样       /message/10
				      query参数路径后使用?去拼接起来的    /xxx/  ? aa = bb && xx = yy  
				

				路由链接传数据给路由：  
				路由传数据给路由组件：



		2、     路由链接组件传递数据给命名路由
				路由链接组件中给路由传参可以写成对象形式，前提需要给路由起名字name，也叫命名路由

	  

		3、	使用props简化路由传参给子组件操作（路由当中传参的三种操作）
				1）布尔值  
				路由当中需要配置 props:true,只能接收params参数，它会把路由当中接收的参数，置为子组件的属性     
				2）对象
				很少用，只能给子组件传递默认静态值
				3）函数
				用的比较多，比较灵活，可以把params和query的参数都映射为子组件的属性
				props(route){ //route就是当前我这个路由对象
                                	//把路由对象当中的参数，不管什么参数
                                	//全部拿到作为子组件的属性去使用
                                	return {
                                    		msgId:route.params.msgId,
                                    		msgContent:route.query.msgContent
                                	}
                            	}


		4、    路由组件和非路由组件的最大区别
			路由组件的生命周期是点击链接的时候，才开始的，路由组件才会创建，mounted才能执行
			路由组件在切换的时候，会被销毁，显示的时候重新创建
			同一个路由组件传参显示不同数据，mounted回调只会执行一次，因为是一个组件
					
		
		
	编程式导航和声明式导航
		前面我们都是借助router-link 自动生成的跳转方式去跳转的，叫做声明式导航
		编程式导航：说白了就是让我们自己手写代码，去跳转

		1)	this.$router.push(path): 相当于点击路由链接(可以返回到当前路由界面)
		2)	this.$router.replace(path): 用新路由替换当前路由(不可以返回到当前路由界面)
		3)	this.$router.back(): 请求(返回)上一个记录路由
		4)	this.$router.go(-1): 请求(返回)上一个记录路由
		5)	this.$router.go(1):  请求下一个记录路由

		$router.push()和$router.replace()的区别，返回有区别。
		$router.push()是往历史记录里面追加
		$router.replace()每一次都是覆盖添加




	缓存路由组件（本质就是切换的时候让原来显示的路由组件不销毁）
		
		
		使用的是vue的一个组件，参考vue的官方文档
		使用这个东西可以保证我们在切换组件的时候，原来显示的组件不被销毁


		<keep-alive include="Home">   Home是对应的组件对象的名字，不是路由的名字
            		<router-view></router-view>
          	</keep-alive>


		
	解决history路由404

		hash模式:
   		 	路径中带#: http://localhost:8080/#/home/news
    			向后台服务器发请求的路径: http://localhost:8080/  项目根路径
    			响应: 返回的总是index页面  ==> path部分(/home/news)被解析为前台路由路径

		history模式:
    			路径中不带#: http://localhost:8080/home/news
    			向后台服务器发请求的路径: http://localhost:8080/home/news
    			响应: 404错误
    			希望: 如果没有对应的资源, 返回index页面, path部分(/home/news)被解析为前台路由路径

    			解决: 添加配置
        			devServer添加: historyApiFallback: true, // 任意的 404 响应都被替代为 index.html
        			output添加: publicPath: '/', // 引入打包的文件时路径以/开头


